# 并发

## ThreadLocal

### 作用

提供线程内的局部变量，可减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。

### 实现原理

每个 Thread 维护一个 ThreadLocalMap 映射表，该表的 key 为 ThreadLocal 实例，value 为需要存储的 Object。

即，ThreadLocal本身不存储值，只作为 key 让线程从 ThreadLocalMap 获取value。


图中的虚线表示 ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key（ThreadLocal 若无强引用，会在GC时被回收）。

为什么不使用强引用

当 ThreadLocal Ref 的对象被回收时，ThreadLocalMap 仍持有 ThreadLocal 强引用，若没有手动删除，会导致 Entry 内存泄漏。

### 隐患——内存泄漏

当 ThreadLocal 无强引用时，会在GC时被回收。则 ThreadLocalMap 中会出现 key 为 null 的 Entry，则无法访问该 Entry 的 value。若线程不结束，则 value 存在一条强引用链：Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value，将无法回收，造成内存泄露。

ThreadLocal 针对上面情况，已有防护措施：在 ThreadLocal 的 get()、set()、remove()的时候会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。

但是！仍然可能内存泄漏：

使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期。

分配了 ThreadLocal，但不调用get()、set()、remove。

内存泄漏的根本原因：ThreadLcoalMap 的生命周期与 Thread 一样长。

### 使用建议

每次使用完 ThreadLocal，调用remove()方法，清除数据。

## BlockingQueue

BlockingQueue 继承 Queue 接口。

提供三个添加元素方法：

| 方法    | 效果                                       |
| ----- | ---------------------------------------- |
| add   | 添加成功返回True，添加失败返回抛出 IllegalStateException 异常 |
| offer | 添加成功返回True，添加失败返回 False                  |
| put   | 若容量满了会阻塞直到                               |

提供三个删除元素方法：

| 方法     | 效果                              |
| ------ | ------------------------------- |
| poll   | 删除队列头部元素，并返回元素，若队列为空，返回null     |
| remove | 基于对象找到元素，并删除。成功返回True，失败返回False |
| take   | 删除队列头部元素，若队列为空，则阻塞直到队列有元素       |

常用阻塞队列：

- ArrayBlockingQueue：基于循环数组，规定大小，FIFO顺序

- LinkedBlockingQueue：基于单向链表，大小不定，FIFO顺序

- PriorityBlockingQueue：基于单向链表，大小不定，按对象的自然排序或其构造函数的Comparator决定的顺序

- LinkedBlockDeque：基于双向链表的双向队列，大小不定


### ArrayBlockingQueue的原理

使用一个可重入锁和该锁生成的两个条件对象进行并发控制（classic two-condition algorithm）

```java
final ReentrantLock lock;
private final Condition notEmpty;
private final Condition notFull;
```

### LinkedBlockingQueue的原理

使用放锁、拿锁，两个锁实现阻塞（"two lock queue" algorithm）

由于有两个锁，所以添加数据和删除数据可并行进行。

不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的同时如果容量还没满，也会唤醒阻塞的线程。

```java
private final ReentrantLock takeLock = new ReentrantLock();
private final Condition notEmpty = takeLock.newCondition();
private final ReentrantLock putLock = new ReentrantLock();
private final Condition notFull = putLock.newCondition();
```

