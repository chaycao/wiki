## 1. 索引的失效情况

（1）条件中有or，有列不带索引

（2）对于多列索引，不是使用的第一部分

（3）like查询以%开头

（4）列是字符串，数据没用引号括起来

（5）mysql估计全表扫描比索引快 

[参考](https://blog.csdn.net/guoxingege/article/details/51034387)



## 2. 索引的实现原理

索引是数据库中一种排序数据结构，通常使用B树及其变种B+树，能有效的利用系统对磁盘的块读取特性，一个节点的大小为一页（4K），每个节点只需要一次IO读取。在读取相同磁盘块的同时，提高索引命中效率，达到减少磁盘IO的读取次数 



## 3. 索引为什么不使用红黑树

虽然红黑树能达到高效的查询效率，但其基本是在内存中才会使用的数据结构。

在数据库中，数据存放在磁盘上，由于操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇，这使得磁盘读写有一个最少内容的限制，也就是当需要簇上的一字节内容，我们需要把整个簇的内容都读完。

试想红黑树中，一个父节点只有两个子节点，不能填满一个簇上的所有内容。一次IO操作获得的簇上只有两个子节点的信息。

再看看B+树，由于B+树节点的分支比二叉树更多，所以相同数量的内容，B+树的深度更浅，也表示磁盘IO操作次数更少。数据库设计的时候B+树具有多少分支是按照磁盘一个簇能存放多少节点设计的。



## 4. 为什么B+树比B树更适合数据库索引？

1. **B+树的磁盘读写次数更少**。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 
2. **B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 
3. **B+树只需要去遍历叶子节点就可以实现整棵树的遍历** ，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 



## 5. 聚簇索引与非聚簇索引

聚簇索引的逻辑顺序是数据在磁盘上的物理存储顺序

非聚簇索引的逻辑顺序与数据在磁盘上的物理存储顺序无关。



## 6. 如何分库分表

**原理：**

通过hash算法或工具将一张数据表垂直或水平地进行物理切分。

**使用场景：** 

1. 单表记录过大，达百万级或千万级；
2. 解决表锁的问题，提高效率

**分表方式：**

1. 水平分表：降低查询时读的数据和索引的页数，降低了索引的层数，提高查询效率
   - 使用场景：
     - 表中数据本身具有独立性，如不同地区数据或不同时期数据，某些数据常用，某些数据不常用
     - 把数据放多个介质上
   - 缺点：
     - 给应用增加复杂度，查询时需要多个表名，查询所有数据需要UNION操作
     - 查询时需要增加读一个索引层的磁盘次数
2. 垂直分表：把主键和一部分列放一个表，接着把主键和另一部分列放一个表。
   - 适用场景：
     - 某些列常用，一些列不常用
   - 缺点：
     - 管理冗余列，查询所有数据需要join操作



## 7. 分区

对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。 

创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有需要的数据的分区，这样只需要查询数据所在分区即可。 

分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性的删除整个分区的数据也很方便。

  **适用场景**  

1、表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据。 

2、分区表的数据更易维护，可以对独立的分区进行独立的操作。 

3、分区表的数据可以分布在不同的机器上，从而高效适用资源。  

4、可以使用分区表来避免某些特殊的瓶颈  

5、可以备份和恢复独立的分区 



## 8. 事务隔离级别

由弱到强：

- 未提交读（Read Uncommited）：（脏读、不可重复读、幻读）
- 已提交读（Read Committed）：只能读到已提交的数据，Oracle等数据库默认级别（不可重复读、幻读）
- 可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别（幻读）
- 串行读（Serializable）：完全串行化的读，每次读都要获取表级共享锁，读写相互阻塞

事务并行产生问题：

- 脏读：当A事务在对数据进行修改，并且还没提交，事务B也能访问、使用该数据 
- 不可重复读：在A事务内，多次读同一数据，由于B事务在两次读数据之间，对数据进行修改，导致两次读到的数据不同（重点在于修改，两次读取的值不同）
- 幻读：A事务对表中所有数据进行修改，事务B修改数据，如插入了一条记录，A事务执行完后，表中存在未修改的数据（重点在于新增或删除，两次读取的记录数不同）



## 9. MVCC

MVCC（Multi-Version Concurrent Control），多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的快照，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这里的版本可以是时间戳或全局递增的事务ID。在同一个时间点，不同的事务看到的数据版本不同。

**mysql 的 InnoDB 引擎如何实现MVCC？** 

为每一行添加两个隐藏字段，记录该行数据何时被创建、何时被删除，具体存储的是事务的版本号，随着新事务开启其版本号会增加。在可重复读Repeated Read级别下：

- SELECT：读取创建版本号 <= 当前事务版本号；删除版本号为空或 > 当前事务版本号
- INSERT：保存当前事务版本号为行的创建版本号
- DELETE：保存当前事务版本号为行的删除版本号
- UPDATE：插入一条新纪录，保存当前事务版本号为行的创建版本号，同时保存当前事务版本号为原来行的删除版本号

**Mysql的RR级别能避免幻读，如何解决？**

Gap锁，在锁住行的两边区间加gap锁，防止别的事务新增。

行锁和Gap锁结合形成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。