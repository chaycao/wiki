{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 用GitBook制作的个人wiki，用于整理知识 "},"src/JavaSE/":{"url":"src/JavaSE/","title":"语法","keywords":"","body":"JavaSE "},"src/JavaSE/语法/foreach.html":{"url":"src/JavaSE/语法/foreach.html","title":"foreach","keywords":"","body":"foreach foreach 在 jdk1.5 加入，当作 for 语法的一个增强。 能使用的类型：数组、java.lang.Iterable 数组：转换为对数组中每个元素的循环引用 Iterable：调用Iterator()返回的迭代器hasNext()、next()遍历 "},"src/JavaSE/语法/反射.html":{"url":"src/JavaSE/语法/反射.html","title":"反射","keywords":"","body":"反射 概念 程序在运行时可以访问、检查、修改它本身状态或行为的一种能力。用比喻来说就是，程序在运行的时候能够“观察”并且修改自己的行为。 原理 // 类的装载、链接、初始化 Class clz = Class.forName(\"ClassA\"); Object instance = clz.newInstance(); // 从 class 对象中获取到 method 方法，执行反射调用 Method method = clz.getMethod(\"myMethod\", String.class); method.invoke(instance, \"abc\",\"efg\"); newInstance()：反射调用了方法 Method.invoke()：调用 native 方法 或 字节码组装 invoke原理： Class 对象维护有一份该类所有的 Method、Field、Constructor，被称作根对象。 每次 getMethod 获取的 Method 对象持有根对象的引用，为了避免每次创建 Method 对象时进行初始化（重量级成员 MethodAccessor，所有Method 共享根对象的 MethodAccessor），每次创建时会调用根对象的 copy 方法。 调用 Method.invoke()，先进行访问权限检查，再获取 MethodAccessor 对象，并调用 MethodAccessor.invoke() 方法。 MethodAccessor 由 ReflectionFactory 创建。创建机制采用 inflation（可由JVM参数noInflation控制是否采用）： 当方法的累积调用次数 若大于，则创建由字节码组装的 MethodAccessorImpl 性能：通过JNI（Java Native Interface）调用native方法初始化更快，但对优化有阻碍作用随着调用次数增多，使用拼装的字节码可以直接以Java调用的方式实现反射，发挥JIT的优化作用 Java反射调用比普通调用慢，原因： Java的invoke方法传递Object、Object[]，对于基本类型需要装箱、拆箱，产生大量额外对象和内存开销，频繁促发GC 编译器难以对动态调用的代码提前做优化，如方法内联 反射需要检索类和方法，有一定时间开销 "},"src/JavaSE/语法/多态.html":{"url":"src/JavaSE/语法/多态.html","title":"多态","keywords":"","body":"多态 概念 允许不同子类型的对象对同一消息做出不同响应，也就是用同样的对象引用调用同样的方法但做了不同的事。 编译时多态：方法重载（overload，用于一个类内实现若干重载的方法，这些方法名称相同而参数形式不同） 运行时多态：方法重写（覆盖，override，用于子类继承父类时，重新实现父类中的方法） 原理 Java的方法调用动态绑定的实现主要依赖于方法表（这里的方法表 指的是虚方法表）。表中每一项都是指向相应方法的指针。其构造如下：方法表中最先存放Object类的方法，接着父类的方法，最后该类本身的方法。 继承：若子类覆盖了父类方法，则子类和父类的同名方法共享一个方法表项，被认为是父类的方法。由于方法的排列特性（Object--父类--子类），使得方法表的偏移量总是固定。（这里相当于是种优化，避免遍历） 在调用方法时： （1）首先查找常量池，找到方法的Class，再得到方法表中的该方法的偏移量 （2）调用对象引用偏移位置的方法接口：不能采用固定偏移量，需要遍历类的方法表查找 通过继承和接口的多态实现有所不同。继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。 接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。 JVM 首先查看 Party 的常量池索引为 12 的条目（应为 CONSTANT_Methodref_info 类型，可视为方法调用的符号引用），进一步查看常量池（CONSTANT_Class_info，CONSTANT_NameAndType_info ，CONSTANT_Utf8_info）可得出要调用的方法是 Person 的 speak 方法（注意引用 girl 是其基类 Person 类型），查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。 "},"src/JavaSE/并发/":{"url":"src/JavaSE/并发/","title":"并发","keywords":"","body":"并发 "},"src/JavaSE/并发/ThreadLocal.html":{"url":"src/JavaSE/并发/ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 作用 提供线程内的局部变量，可减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。 实现原理 每个 Thread 维护一个 ThreadLocalMap 映射表，该表的 key 为 ThreadLocal 实例，value 为需要存储的 Object。 即，ThreadLocal本身不存储值，只作为 key 让线程从 ThreadLocalMap 获取value。 图中的虚线表示 ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key（ThreadLocal 若无强引用，会在GC时被回收）。 为什么不使用强引用 当 ThreadLocal Ref 的对象被回收时，ThreadLocalMap 仍持有 ThreadLocal 强引用，若没有手动删除，会导致 Entry 内存泄漏。 隐患——内存泄漏 当 ThreadLocal 无强引用时，会在GC时被回收。则 ThreadLocalMap 中会出现 key 为 null 的 Entry，则无法访问该 Entry 的 value。若线程不结束，则 value 存在一条强引用链：Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value，将无法回收，造成内存泄露。 ThreadLocal 针对上面情况，已有防护措施：在 ThreadLocal 的 get()、set()、remove()的时候会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。 但是！仍然可能内存泄漏： 使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期。 分配了 ThreadLocal，但不调用get()、set()、remove。 内存泄漏的根本原因：ThreadLcoalMap 的生命周期与 Thread 一样长。 使用建议 每次使用完 ThreadLocal，调用remove()方法，清除数据。 "},"src/JavaSE/并发/BlockingQueue.html":{"url":"src/JavaSE/并发/BlockingQueue.html","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue 继承 Queue 接口。 提供三个添加元素方法： 方法 效果 add 添加成功返回True，添加失败返回抛出 IllegalStateException 异常 offer 添加成功返回True，添加失败返回 False put 若容量满了会阻塞直到 提供三个删除元素方法： 方法 效果 poll 删除队列头部元素，并返回元素，若队列为空，返回null remove 基于对象找到元素，并删除。成功返回True，失败返回False take 删除队列头部元素，若队列为空，则阻塞直到队列有元素 常用阻塞队列： ArrayBlockingQueue：基于循环数组，规定大小，FIFO顺序 LinkedBlockingQueue：基于单向链表，大小不定，FIFO顺序 PriorityBlockingQueue：基于单向链表，大小不定，按对象的自然排序或其构造函数的Comparator决定的顺序 LinkedBlockDeque：基于双向链表的双向队列，大小不定 ArrayBlockingQueue的原理 使用一个可重入锁和该锁生成的两个条件对象进行并发控制（classic two-condition algorithm） final ReentrantLock lock; private final Condition notEmpty; private final Condition notFull; LinkedBlockingQueue的原理 使用放锁、拿锁，两个锁实现阻塞（\"two lock queue\" algorithm） 由于有两个锁，所以添加数据和删除数据可并行进行。 不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的同时如果容量还没满，也会唤醒阻塞的线程。 private final ReentrantLock takeLock = new ReentrantLock(); private final Condition notEmpty = takeLock.newCondition(); private final ReentrantLock putLock = new ReentrantLock(); private final Condition notFull = putLock.newCondition(); "},"src/JavaSE/JNI/JNI.html":{"url":"src/JavaSE/JNI/JNI.html","title":"JNI","keywords":"","body":"JNI 概念 JNI（Java Native Interface） 是Java平台的一部分，可以实现与其他语言（如C、C++）进行交互 JNI 是完善 Java 功能的一个重要功能： JVM 封装了各种操作系统的差异性，可使得 Java 程序跨平台 JNI 提供了 Java 程序与操作系统相关功能函数交互的接口 应用场景 程序对时间敏感或对性能要求特别高，有必要用更底层的语言（如汇编、C、C++） 在已有现成的用其他语言已完成的功能时，需要用 Java 去调用 在需要用到 Java 标准平台不具备的依赖于操作系统的特性时 原理 调用过程示例图 使用步骤 在 Java 类中声明 Native 方法，类中同时需要加载使用的动态库 用 javah 程序，将上步中的 class 文件生成头文件 javah -jni XXX javah 程序统一了 Java 中的 native 方法、头文件中的函数名和动态库中的函数实现之间的对应关系 用其他语言（如C、C++）实现上述头文件中的函数，生成动态库，供 Java 程序使用 发布 Java 和动态库 实例 环境：Ubuntu 10.4.2 LTS系统 package com.magc.jni; public class HelloWorld { static { System.loadLibrary(\"Hello\"); } public native void DisplayHello(); public static void main(String[] args) { new HelloWorld().DisplayHello(); } } 进入src目录下，编译该JAVA类， javac ./com/magc/jni/HelloWorld.java 在该HelloWorld.java所在目录下生成HelloWorld.class 然后使用javah生成头文件， javah -jni com.magc.jni.HelloWorld 在当前目录下生成com_magc_jni_HelloWorld.h头文件，此文件供C、C++程序来引用并实现其中的函数 /* DO NOT EDIT THIS FILE - it is machine generated */ #include /* Header for class com_magc_jni_HelloWorld */ #ifndef _Included_com_magc_jni_HelloWorld #define _Included_com_magc_jni_HelloWorld #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_magc_jni_HelloWorld * Method: DisplayHello * Signature: ()V */ JNIEXPORT void JNICALL Java_com_magc_jni_HelloWorld_DisplayHello (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 注：1)、此头文件是不需要用户编译的，直接供其它C、C++程序引用。 2)、此头文件中的Java_com_magc_jni_HelloWorld_DisplayHello(JNIEnv *, jobject)方法，是将来与动态链接库交互的接口，并需要名字保持一致。 #include #include \"com_magc_jni_HelloWorld.h\" #include JNIEXPORT void JNICALL Java_com_magc_jni_HelloWorld_DisplayHello (JNIEnv *env, jobject obj) { printf(\"From jni_helloworldImpl.cpp :\"); printf(\"Hello world ! \\n\"); return; } 此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。 编译生成动态库 libHello.so g++ -shared -I /usr/lib/jvm/java-6-openjdk/include jni_helloworldImpl.cpp -o libHello.so 成功后，便会在当前目录下生成动态链接库libHello.so文件。 有了具体实现的动态库后，就可以运行 JAVA 调用 JNI程序类的 native 方法了。 java -Djava.library.path=. com.magc.jni.HelloWorld "},"src/JVM/运行时数据区域/运行时数据区域.html":{"url":"src/JVM/运行时数据区域/运行时数据区域.html","title":"运行时数据区域","keywords":"","body":"运行时数据区域 程序计数器 记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为零）。 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小： java -Xss=512M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈 与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 堆 所有对象实例都在这里分配内存。 是垃圾收集的主要区域（\"GC 堆\"），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块： 新生代（Young Generation） 老年代（Old Generation） 永久代（Permanent Generation） 当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间： Eden From Survivor To Survivor Java 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 java -Xms=1M -Xmx=2M HackTheJava 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK 1.8 之后，取消了永久代，用 metaspace（元数据）区替代。 运行时常量池 运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。 直接内存 在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 二、垃圾收集 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。 判断一个对象是否可回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 public class ReferenceCountingGC { public Object instance = null; public static void main(String[] args) { ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; } } 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 2. 可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 3. 引用类型 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。 Java 具有四种强度不同的引用类型。 （一）强引用 被强引用关联的对象不会被垃圾收集器回收。 使用 new 一个新对象的方式来创建强引用。 Object obj = new Object(); （二）软引用 被软引用关联的对象，只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 Object obj = new Object(); SoftReference sf = new SoftReference(obj); obj = null; // 使对象只被软引用关联 （三）弱引用 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。 使用 WeakReference 类来实现弱引用。 Object obj = new Object(); WeakReference wf = new WeakReference(obj); obj = null; WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。 private static class Entry extends WeakReference implements Map.Entry Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。 public final class ConcurrentCache { private final int size; private final Map eden; private final Map longterm; public ConcurrentCache(int size) { this.size = size; this.eden = new ConcurrentHashMap<>(size); this.longterm = new WeakHashMap<>(size); } public V get(K k) { V v = this.eden.get(k); if (v == null) { v = this.longterm.get(k); if (v != null) this.eden.put(k, v); } return v; } public void put(K k, V v) { if (this.eden.size() >= size) { this.longterm.putAll(this.eden); this.eden.clear(); } this.eden.put(k, v); } } （四）虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 Object obj = new Object(); PhantomReference pf = new PhantomReference(obj); obj = null; 4. 方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 5. finalize() finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。 垃圾收集算法 1. 标记 - 清除 将需要存活的对象进行标记，然后清理掉未被标记的对象。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 2. 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 4. 分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 1. Serial 收集器 Serial 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器 与 ParNew 一样是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。 4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。 G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 更详细内容请参考：Getting Started with the G1 Garbage Collector 8. 比较 收集器 串行/并行/并发 新生代/老年代 收集算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 串行 + 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 串行 + 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 串行 + 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并行 + 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并行 + 并发 新生代 + 老年代 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略 对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 1. Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 2. 内存分配策略 （一）对象优先在 Eden 分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 （二）大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 （三）长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 （四）动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 （五）空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 3. Full GC 的触发条件 对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： （一）调用 System.gc() 此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。 （二）老年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 （三）空间分配担保失败 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 （四）JDK 1.7 及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 （五）Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 三、类加载机制 类是在运行期间动态加载的。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 类初始化时机 虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随着发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 System.out.println(ConstClass.HELLOWORLD); 类加载过程 包含了加载、验证、准备、解析和初始化这 5 个阶段。 1. 加载 加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用是 Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ... 2. 验证 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。 字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。 符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 3. 准备 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次） 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 public static final int value = 123; 4. 解析 将常量池的符号引用替换为直接引用的过程。 5. 初始化 初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 () 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” } static int i = 1; } 与类的构造函数（或者说实例构造器 ()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 () 方法运行之前，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： static class Parent { public static int A = 1; static { A = 2; } } static class Sub extends Parent { public static int B = A; } public static void main(String[] args) { System.out.println(Sub.B); // 输出结果是父类中的静态变量 A 的值，也就是 2。 } () 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 () 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类加载器 实现类的加载动作。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。 1. 类与类加载器 两个类相等：类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 2. 类加载器分类 从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 3. 双亲委派模型 应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 （一）工作过程 一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。 （二）好处 使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。正因为 rt.jar 中的 Object 优先级更高，因为程序中所有的 Object 都是这个 Object。 （三）实现 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 public abstract class ClassLoader { // The parent class loader for delegation private final ClassLoader parent; public Class loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } protected Class findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } } 4. 自定义类加载器实现 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 类的方法 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，而是通过重写 findClass() 方法。 public class FileSystemClassLoader extends ClassLoader { private String rootDir; public FileSystemClassLoader(String rootDir) { this.rootDir = rootDir; } protected Class findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { String path = classNameToPath(className); try { InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; } } 四、JVM 参数 GC 优化配置 配置 描述 -Xms 初始化堆内存大小 -Xmx 堆内存最大值 -Xmn 新生代大小 -XX:PermSize 初始化永久代大小 -XX:MaxPermSize 永久代最大容量 GC 类型设置 配置 描述 -XX:+UseSerialGC 串行垃圾回收器 -XX:+UseParallelGC 并行垃圾回收器 -XX:+UseConcMarkSweepGC 并发标记扫描垃圾回收器 -XX:ParallelCMSThreads= 并发标记扫描垃圾回收器 = 为使用的线程数量 -XX:+UseG1GC G1 垃圾回收器 java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar "},"src/JVM/垃圾回收/垃圾回收.html":{"url":"src/JVM/垃圾回收/垃圾回收.html","title":"垃圾回收","keywords":"","body":"垃圾回收 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。 判断一个对象是否可回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 缺点：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 public class ReferenceCountingGC { public Object instance = null; public static void main(String[] args) { ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; } } Java 虚拟机不使用引用计数算法。 2. 可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 3. 引用类型 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。 Java 具有四种强度不同的引用类型。 （一）强引用 被强引用关联的对象不会被垃圾收集器回收。 使用 new 一个新对象的方式来创建强引用。 Object obj = new Object(); （二）软引用 被软引用关联的对象，只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 Object obj = new Object(); SoftReference sf = new SoftReference(obj); obj = null; // 使对象只被软引用关联 （三）弱引用 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。 使用 WeakReference 类来实现弱引用。 Object obj = new Object(); WeakReference wf = new WeakReference(obj); obj = null; WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。 private static class Entry extends WeakReference implements Map.Entry Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。 public final class ConcurrentCache { private final int size; private final Map eden; private final Map longterm; public ConcurrentCache(int size) { this.size = size; this.eden = new ConcurrentHashMap<>(size); this.longterm = new WeakHashMap<>(size); } public V get(K k) { V v = this.eden.get(k); if (v == null) { v = this.longterm.get(k); if (v != null) this.eden.put(k, v); } return v; } public void put(K k, V v) { if (this.eden.size() >= size) { this.longterm.putAll(this.eden); this.eden.clear(); } this.eden.put(k, v); } } （四）虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 Object obj = new Object(); PhantomReference pf = new PhantomReference(obj); obj = null; 4. 方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 5. finalize() finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。 垃圾收集算法 1. 标记 - 清除 将需要存活的对象进行标记，然后清理掉未被标记的对象。 缺点： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 2. 标记 - 整理 标记存活的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 4. 分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 1. Serial 收集器 Serial 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 优点：简单高效。对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器 与 ParNew 一样是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。 4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。 G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 更详细内容请参考：Getting Started with the G1 Garbage Collector 8. 比较 收集器 串行/并行/并发 新生代/老年代 收集算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 串行 + 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 串行 + 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 串行 + 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并行 + 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并行 + 并发 新生代 + 老年代 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略 对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 1. Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 2. 内存分配策略 （一）对象优先在 Eden 分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 （二）大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 （三）长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 （四）动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 （五）空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 3. Full GC 的触发条件 对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： （一）调用 System.gc() 此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。 （二）老年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 （三）空间分配担保失败 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 （四）JDK 1.7 及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 （五）Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 "},"src/面试真题/Java.html":{"url":"src/面试真题/Java.html","title":"Java","keywords":"","body":"1. HashMap什么情况下发生死链 JDK1.8之前，并发resize()的时候可能会发生死链。 参考 2. HashMap HashMap的特性？ HashMap 存储键值对，实现快速存取数据；允许null键\\值；非同步；不保证有序 HashMap的原理，内部数据结构？ 基于hashing的原理，jdk1.8之前底层使用哈希表（数组+链表）实现。jdk1.8之后，当链表长度大于8时，将链表转换成红黑树。 HashMap中的最重要两个方法put、get put方法的原理：传入k，v，通过取hashcode，高位参与运算、取模运算三步，获得bucket位置，进行存储，如果没有碰撞直接放bucket里，如果碰撞，以链表形式存在buctets后，如果节点已经存在就替换oldvalue。当hashmap的bucket占用情况超过capacity*load_factor则，通过resize方法扩容为2倍。 get方法的原理：传入k，通过取hashcode，高位参与运算、取模运算三步，获得bucket位置，并进一步调用equals方法确定键值对。 当两个对象的hashcode相同会发生什么？ 若两个对象的hashcode相同，则他们的bucket位置相同，会发生碰撞。 有哪些hash的实现方式？ 直接定址法：取k的某个线性函数值为散列地址。 数字分析法：提取关键字k中取值比较均匀的数字作为哈希地址。例如，生日使用月份和日期构成散列地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 有哪些hash冲突解决办法？ 开放地址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出表：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 为什么String、Integer适合作为键？ 已重写了equals()和hashCode()。（让不相等的对象返回不同的hashcode值） 具有不可变性，可防止键值的改变，线程安全 HashMap与HashTable区别？ 线程安全性。HashTable中几乎所有函数是同步的，所以它是线程安全的。HashMap是线程不安全的。 NULL值。HashMap的key、value都可为null，Hashtable都不可为null 容器的初始值和扩容方式。HashMap默认16，扩容 （原始容量2）,；HashTable默认11，扩容 （原始容量 2+1） HashMap继承于AbstractMap，HashTable继承于Dictionary hash算法。HashMap自定义的哈希算法；HashTable直接采用key的hashCode()； 速度。单线程环境下HashMap更快 让HashMap同步 Collections.synchronizeMap() 3. 多线程顺序执行 （1） 有A、B、C、D四个线程，A线程输出A, B线程输出B, C线程输出C，D线程输出D，要求, 同时启动四个线程, 按顺序输出ABCD 答：通过Thread.join()方法，B、C、D分别持有A、B、C的引用，并且在输出前调用持有线程的join方法，等待线程执行完毕，再输出。 package thread; public class TestThread1 { public static void main(String[] args) { // 线程A final Thread a = new Thread(new Runnable() { @Override public void run() { System.out.println(\"A\"); } }); // 线程B final Thread b = new Thread(new Runnable() { @Override public void run() { try { // 执行b线程之前，加入a线程,让a线程执行 a.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"B\"); } }); // 线程C final Thread c = new Thread(new Runnable() { @Override public void run() { try { // 执行c线程之前，加入b线程,让b线程执行 b.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"C\"); } }); // 线程D Thread d = new Thread(new Runnable() { @Override public void run() { try { // 执行d线程之前，加入c线程,让c线程执行 c.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"D\"); } }); // 启动四个线程 a.start(); b.start(); c.start(); d.start(); } } （2） 有A,B,C三个线程, A线程输出A, B线程输出B, C线程输出C。要求, 同时启动三个线程, 按顺序输出ABC, 循环10次 使用ReentrantLock控制并发,并使用一个state整数来判断应哪个线程执行。 public class Test { private static ReentrantLock lock = new ReentrantLock(); private static int state = 0; static class A extend Thread() { @Override public void run() { lock.lock(); for (int i = 0; i 4. hashCode()与equals() equals()方法用来判断两个对象是否相等，Object默认比较对象地址 hashCode()方法用来获取哈希码，Object默认根据对象地址转换成一个整数 为什么重写equals()一定要重写hashCode()方法 这是因为HashMap等哈希表是由hashcode()定位要存放的位置，而equals()判断是否相等，这意味着逻辑上equals()相等，认为这两个对象相等则应该放在同一个桶中，所以hashcode()也需要相等。 "},"src/面试真题/JVM.html":{"url":"src/面试真题/JVM.html","title":"JVM","keywords":"","body":"1. Java什么时候会发生内存泄露 内存泄露是指不再使用的对象，被某个对象持有该引用导致GC不能回收。有以下几种情况： 使用静态成员变量的容器对象，持有过多数据 连接资源未释放，如数据库连接、网络连接、IO连接等，其原因是长生命周期对象拥有短生命周期对象引用 2. GC算法和机制 从三个方面讲述 （1）什么时候触发GC 当新生代中的eden区满了，会触发minor gc； 当要升到老年代的对象大于老年代剩余空间会触发full gc，或者小于时被HandlePromotionFailure参数强制full gc。 （2）哪些对象需要被回收 从GC Roots搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 （3）如何回收 对于新生代使用复制算法，将Eden和from surivor中还活着的对象一次性复制到to surivor中，再清理掉Eden和From Survior空间。 对于老年代使用标记清除或标记整理算法。标记清除首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象，但是会产生大量不连续的内存碎片；标记整理的标记与标记清除相同，但不是直接回收对象，而是将所有存活的对象向一端移动，然后直接清理掉边界以外的内存 。 3. JVM内存模型 JVM内存模型被分为以下几个区域： （1）程序计数器：记录当前线程执行字节码指令的地址 （2）虚拟机栈：当方法执行时，会创建一个栈帧，存放局部变量表、操作数栈、方法出口等信息。 （3）本地方法栈：Native方法执行时使用，与虚拟机栈类似 （4）虚拟机堆：所有创建的对象都在堆中分配内存并初始化 （5）方法区：存放虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等信息 其中程序计数器、虚拟机栈、本地方法栈为线程私有 "},"src/面试真题/SpringMVC.html":{"url":"src/面试真题/SpringMVC.html","title":"SpringMVC","keywords":"","body":"1. SpringMVC的工作流程 （1）用户发送请求到DispatcherServlet （2）DispatcherServlet收到请求后调用HandlerMapping （3）HandlerMapping根据请求的URL找到具体的处理器，生成处理器对象及处理器拦截器，返回给DispatcherServlet （4）DispatcherServlet调用HandlerAdapter （5）通过HandlerAdapter调用处理器 （6）处理器执行完后返回ModelAndView （7）HandlerAdapter将ModelAndView返回给DispatcherServlet （8）DispatcherServlet将ModelAndView传给ViewReslover （9）ViewReslover解析后返回具体View给DispatcherServlet （10）DispatcherServlet使用Model对View进行视图渲染（模型数据填充到视图中） （11）DispatcherServlet响应用户 "},"src/面试真题/数据库.html":{"url":"src/面试真题/数据库.html","title":"数据库","keywords":"","body":"1. 索引的失效情况 （1）条件中有or，有列不带索引 （2）对于多列索引，不是使用的第一部分 （3）like查询以%开头 （4）列是字符串，数据没用引号括起来 （5）mysql估计全表扫描比索引快 参考 2. 索引的实现原理 索引是数据库中一种排序数据结构，通常使用B树及其变种B+树，能有效的利用系统对磁盘的块读取特性，一个节点的大小为一页（4K），每个节点只需要一次IO读取。在读取相同磁盘块的同时，提高索引命中效率，达到减少磁盘IO的读取次数 3. 索引为什么不使用红黑树 虽然红黑树能达到高效的查询效率，但其基本是在内存中才会使用的数据结构。 在数据库中，数据存放在磁盘上，由于操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇，这使得磁盘读写有一个最少内容的限制，也就是当需要簇上的一字节内容，我们需要把整个簇的内容都读完。 试想红黑树中，一个父节点只有两个子节点，不能填满一个簇上的所有内容。一次IO操作获得的簇上只有两个子节点的信息。 再看看B+树，由于B+树节点的分支比二叉树更多，所以相同数量的内容，B+树的深度更浅，也表示磁盘IO操作次数更少。数据库设计的时候B+树具有多少分支是按照磁盘一个簇能存放多少节点设计的。 4. 为什么B+树比B树更适合数据库索引？ B+树的磁盘读写次数更少。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 B+树只需要去遍历叶子节点就可以实现整棵树的遍历 ，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 5. 聚簇索引与非聚簇索引 聚簇索引的逻辑顺序是数据在磁盘上的物理存储顺序 非聚簇索引的逻辑顺序与数据在磁盘上的物理存储顺序无关。 6. 如何分库分表 原理： 通过hash算法或工具将一张数据表垂直或水平地进行物理切分。 使用场景： 单表记录过大，达百万级或千万级； 解决表锁的问题，提高效率 分表方式： 水平分表：降低查询时读的数据和索引的页数，降低了索引的层数，提高查询效率 使用场景： 表中数据本身具有独立性，如不同地区数据或不同时期数据，某些数据常用，某些数据不常用 把数据放多个介质上 缺点： 给应用增加复杂度，查询时需要多个表名，查询所有数据需要UNION操作 查询时需要增加读一个索引层的磁盘次数 垂直分表：把主键和一部分列放一个表，接着把主键和另一部分列放一个表。 适用场景： 某些列常用，一些列不常用 缺点： 管理冗余列，查询所有数据需要join操作 7. 分区 对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。 创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有需要的数据的分区，这样只需要查询数据所在分区即可。 分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性的删除整个分区的数据也很方便。 适用场景 1、表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据。 2、分区表的数据更易维护，可以对独立的分区进行独立的操作。 3、分区表的数据可以分布在不同的机器上，从而高效适用资源。 4、可以使用分区表来避免某些特殊的瓶颈 5、可以备份和恢复独立的分区 8. 事务隔离级别 由弱到强： 未提交读（Read Uncommited）：（脏读、不可重复读、幻读） 已提交读（Read Committed）：只能读到已提交的数据，Oracle等数据库默认级别（不可重复读、幻读） 可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别（幻读） 串行读（Serializable）：完全串行化的读，每次读都要获取表级共享锁，读写相互阻塞 事务并行产生问题： 脏读：当A事务在对数据进行修改，并且还没提交，事务B也能访问、使用该数据 不可重复读：在A事务内，多次读同一数据，由于B事务在两次读数据之间，对数据进行修改，导致两次读到的数据不同（重点在于修改，两次读取的值不同） 幻读：A事务对表中所有数据进行修改，事务B修改数据，如插入了一条记录，A事务执行完后，表中存在未修改的数据（重点在于新增或删除，两次读取的记录数不同） 9. MVCC MVCC（Multi-Version Concurrent Control），多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的快照，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这里的版本可以是时间戳或全局递增的事务ID。在同一个时间点，不同的事务看到的数据版本不同。 mysql 的 InnoDB 引擎如何实现MVCC？ 为每一行添加两个隐藏字段，记录该行数据何时被创建、何时被删除，具体存储的是事务的版本号，随着新事务开启其版本号会增加。在可重复读Repeated Read级别下： SELECT：读取创建版本号 当前事务版本号 INSERT：保存当前事务版本号为行的创建版本号 DELETE：保存当前事务版本号为行的删除版本号 UPDATE：插入一条新纪录，保存当前事务版本号为行的创建版本号，同时保存当前事务版本号为原来行的删除版本号 Mysql的RR级别能避免幻读，如何解决？ Gap锁，在锁住行的两边区间加gap锁，防止别的事务新增。 行锁和Gap锁结合形成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。 "},"src/面试真题/计算机网络.html":{"url":"src/面试真题/计算机网络.html","title":"计算机网络","keywords":"","body":"1. cookie与session的原理和区别 "},"src/面试真题/算法.html":{"url":"src/面试真题/算法.html","title":"算法","keywords":"","body":"1. 乱序算法 public static void shuffle(int[] array) { for (int i = array.length-1; i > 0; i--) { Random random = new Random(); int x = random.nextInt(i); swap(array, x, i); } } public static void swap(int[] array, int a, int b) { int temp = array[a]; array[a] = array[b]; array[b] = temp; } "},"src/面试真题/大数据.html":{"url":"src/面试真题/大数据.html","title":"大数据","keywords":"","body":"1. 两个大文件找出共同记录 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url? 采用分治法的思想 第一步，遍历文件a，设计一个hash函数，将url划分成多个小文件，例如划分成1000个，则对每个url取Hash(url)%1000，得到1000个小文件 第二步，遍历文件b，用与a同样的方式，将url划分成小文件，这里使用相同的hash函数，也同样得到1000个小文件。 现在问题转换成了，找出1000对小文件中每一对相同的url读取小文件a，建立哈希表，再读取文件b，对于每个url，若在hash表中搜索到，则说明两者共有，存起来 https://blog.csdn.net/v_july_v/article/details/7382693 https://blog.csdn.net/v_JULY_v/article/details/6279498 "},"src/Python/环境/":{"url":"src/Python/环境/","title":"环境","keywords":"","body":"环境 "},"src/Python/环境/包导出.html":{"url":"src/Python/环境/包导出.html","title":"包导出","keywords":"","body":"包导出 pip导出 pip freeze > requirements.txt pip wheel -r requirements.txt pip install --use-wheel --no-index --find-links=wheelhouse -r requirements.txt "},"src/Web/XML.html":{"url":"src/Web/XML.html","title":"XML","keywords":"","body":"XML XML的生成解析方法 DOM DOM（Document Object MOdel）是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。 优点： 允许应用程序对数据和结构做出更改。 访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。 编程容易 缺点： 通常需要加载整个XML文档来构造层次结构，消耗资源大。 使用场景： XML文档需要频繁改变 SAX SAX采用事件模型，在解析XML文档时可以促发一系列事件，当发现给定 tag 时，可以激活一个回调函数，告诉该方法 tag 已找到。SAX对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag.特别是当开发人员只需要处理文档中所包含的部分数据时，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据。 优点： 不需要等待所有数据都被处理，分析就能立即开始。 只在读取数据时检查数据，不需要保存在内存中。 可以在某个条件得到满足时停止解析，不必解析整个文档。 效率和性能较高，能解析大于系统内存的文档。 缺点： 需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂。 单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。 JDOM JDOM（Java-based Document Object Model）与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。 JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。 优点： 使用具体类而不是接口，简化了DOM的API。 大量使用了Java集合类，方便了Java开发人员。 缺点： 没有较好的灵活性。 性能较差。 DOM4J DOM4J（Document Object Model for Java）合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。 优点： 大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法。 支持XPath。 有很好的性能。 缺点： 大量使用了接口，API较为复杂。 比较 DOM4J 性能最好，若不考虑可移植性，则推荐采用 JDOM、DOM 在性能上表现不佳，但可移植 SAX 性能表现较好 如果XML文档较大且不考虑移植性问题建议采用DOM4J； 如果XML文档较小则建议采用JDOM； 如果需要及时处理而不需要保存数据则考虑SAX。 "},"src/Linux/常用命令.html":{"url":"src/Linux/常用命令.html","title":"常用命令","keywords":"","body":"常用命令 查看CPU信息 CPU的信息在启动过程中被装载到虚拟目录/proc下的cpuinfo中 cat /proc/cpuinfo 重要指标： process：逻辑处理器的ID physical id：物理封装的处理器ID siblings：位于相同物理封装的处理器中的逻辑处理器的忽略 cpu id：内核的ID cpu cores：位于相同物理封装的处理器中的内核数量 在该服务器上 physical id 有2个 —— 有两个物理CPU cpu cores 为4 —— 1个物理CPU里有4个内核 core id 有8个 —— 总共有8个内核 (所有物理CPU内核总数） silbings 为8 —— 1个物理CPU里有8个逻辑CPU processor 有16个——总共有16个逻辑CPU 总核数 = 物理CPU个数 * 每颗物理CPU的核数 总逻辑CPU数 = 物理CPU个数 每颗物理CPU的核数 超线程数 # 查看物理CPU个数 cat /proc/cpuinfo| grep 'physical id'| sort| uniq| wc -l # 查看每个物理CPU的核数 cat /proc/cpuinfo| grep 'cpu cores'| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep 'processor'| wc -l 查看系统负载 Linux 的负载高，主要是由于下面三部分构成： CPU使用 内存使用 IO消耗 1.uptime 系统平均负载：特定时间间隔内运行队列中的平均进程数 若每个CPU内核的当前活动进程数不大于3，性能良好 若大于5，则系统超负荷运转 2.w 3.top Linux下的任务管理器，能够实时显示系统中各个进程的资源占用状况，查看命令详细) 4.free 相比top，提供更简洁的系统内存使用情况，查看命令详细 5.vmstat 展现给定时间间隔的服务器状态值，如CPU使用率、内存使用、虚拟内存交换情况、IO读写情况，查看命令详细 查看网卡流量 sar "},"src/Linux/常用命令/文件及目录管理.html":{"url":"src/Linux/常用命令/文件及目录管理.html","title":"文件及目录管理","keywords":"","body":"文件及目录管理 创建和删除 创建：mkdir 删除：rm 删除非空目录：rm - rf 目录 删除日志：rm \\*log（等价：find ./ -name \"\\*log\" -exec rm {};） 移动：mv 复制：cp （复制目录：cp -r source_dir dest_dir） 查看当前目录下文件个数：find ./ | wc -l 目录切换 切到文件\\目录位置：cd 目录 切到上一个目录：cd .. 切到home目录：cd ~ 显示当前路径：pwd 列出目录项 显示当前目录下的文件：ls 按时间排序，以列表方式显示目录项：ls -lrt 查找目录及文件 按部分文件名搜索文件或目录：find ./ -name \"core*\" 查看文件内容 查看文件：cat、vi、head、tail、more 查找文件内容 查找文件内容：egrep 查找字符串 文件或目录 文件与目录权限修改 改变文件的拥有者：chown 改变文件读、写、执行等属性：chmod 递归子目录修改：chown -R tuxapp source/ 增加脚本可执行权限：chmod a+x myscript 文件增加别名 创造硬链接：ln 源目录 目标文件 创造软链接：ln -s 源目录 目标文件 管道和重定向 批处理命令连接执行：| 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行: && 前面失败，则后一条执行: || "},"src/Linux/常用命令/磁盘管理.html":{"url":"src/Linux/常用命令/磁盘管理.html","title":"磁盘管理","keywords":"","body":"磁盘管理 查看磁盘空间 查看磁盘空间利用大小：df -h 查看当前目录所占空间：du -sh 查看当牧师所有子文件排序后的大小：du -sh 'ls' | sort "},"src/Linux/常用命令/进程管理.html":{"url":"src/Linux/常用命令/进程管理.html","title":"进程管理","keywords":"","body":"进程管理 查询进程 查询正在运行的进程信息：ps -ef 根据进程名查询进程：pgrep -l 进程名 显示进程信息，并实时更新：top 查看端口占用的进程状态：lsof -i:3306 查询用户user的进程所打开的文件：lsof -u user 查询init进程当前打开的文件：lsof -c init 查询指定进程ID打开的文件：lsof -p ID 查询指定目录下被进程开启的文件：lsof +d 目录 终止进程 杀死指定PID的进程：kill PID 杀死相关进程：kill -9 3434 进程监控 查询系统CPU、使用内存最多的进程：top，再输入P，进行排序 分析线程栈 输出进程内存的状态：pmap "},"src/Linux/常用命令/性能管理.html":{"url":"src/Linux/常用命令/性能管理.html","title":"性能管理","keywords":"","body":"性能管理 "},"src/Linux/":{"url":"src/Linux/","title":"命令详解","keywords":"","body":"命令详解 "},"src/Linux/命令详解/top.html":{"url":"src/Linux/命令详解/top.html","title":"top","keywords":"","body":"TOP 能够实时显示系统中各个进程的资源占用状况 统计信息区（前5行） 第一行，任务队列信息，同 uptime 命令的执行结果 第二行，Tasks，系统共有435个进程，其中2个在运行，433个在休眠，0个stoped，0个zombie（僵尸） 第三行，CPU状态 us —— 用户空间占用CPU的百分比 sy —— 内核空间占用CPU的百分比 ni —— 改变过优先级的进程占用CPU的百分比 id —— 空间CPU百分比 wa —— IO等待占用CPU的百分比 hi ——硬中断占用CPU的百分比 si —— 软中断占用CPU的百分比 第四行，内存状态 total —— 物理内存总量 userd —— 使用内存总量 free —— 空闲内存总量 buffers —— 缓存内存总量 第五行，swap交换分区信息 交换区总量 使用交换区总量 空闲交换区总量 缓存交换区总量 备注： 第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。 如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存 对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。 各进程（任务）的状态监控（第七行以下） PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） "},"src/Linux/命令详解/free.html":{"url":"src/Linux/命令详解/free.html","title":"free","keywords":"","body":"free 相比top，提供更简洁的系统内存使用情况 参数说明 Mem：表示物理内存统计 Total：表示物理内存总大小。 Used：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。 Free：表示未被分配的内存。 Shared：共享内存，一般系统不会用到。 Buffers：系统分配但未被使用的buffers 数量。 Cached：系统分配但未被使用的cache 数量。 -/+ buffers/cached：表示物理内存的缓存统计 Used：实际使用的buffers 与cache 总量，也是实际使用的内存总量。 Free: 未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。 Swap：表示硬盘上交换分区的使用情况。只有mem被当前进程实际占用完,即没有了buffers和cache时，才会使用到swap。 实际可用内存大小： ​ Free（-/+ buffers/cache行）= Free(Mem)+buffers(Mem)+Cached(Mem); 已经分配的内存大小： ​ Used(Mem) = Used(-/+ buffers/cache)+ buffers(Mem) + Cached(Mem) 物理内存总大小 ​ total（Mem） = used(-/+ buffers/cache) + free(-/+ buffers/cache) ​ 1035108 = 471772 + 563336 buffer 与 cache 的区别 A buffer is something that has yet to be \"written\" to disk. A cache is something that has been \"read\" from the disk and stored for later use. cache Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。 由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。 Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。 buffer Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 比较 在Free命令中显示的buffer和cache，它们都是占用内存： buffer : 作为buffer cache的内存，是块设备的读写缓冲区，更靠近存储设备，或者直接就是disk的缓冲区。 cache: 作为page cache的内存, 文件系统的cache，是memory的缓冲区 如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。 "},"src/Linux/命令详解/vmstat.html":{"url":"src/Linux/命令详解/vmstat.html","title":"vmstat","keywords":"","body":"vmstat 展现给定时间间隔的服务器状态值，如CPU使用率、内存使用、虚拟内存交换情况、IO读写情况 参数： 采用的时间间隔数，单位秒 采样的次数 r 表示正在跑的任务数，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。 b 表示阻塞的进程。 swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。 free 空闲的物理内存的大小。 buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存 cache cache直接用来记忆我们打开的文件,给文件做缓冲(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。) si 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。 so 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte。 bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 in 每秒CPU的中断次数，包括时间中断 cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。 us 用户进程执行时间百分比，值高，说明用户进程消耗的CPU时间多，若长期超过50%，该考虑优化程序算法或进行加速。 sy 内核系统进程执行时间百分比，如果太高，表示系统调用时间长，例如是IO操作频繁。 id 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。 wa 等待IO CPU时间，值高，说明IO等待严重，可能由于磁盘大量做随机访问造成，也有可能磁盘出现瓶颈（块操作）。 "},"src/MySQL/":{"url":"src/MySQL/","title":"锁","keywords":"","body":"锁 "},"src/MySQL/锁/悲观锁与乐观锁.html":{"url":"src/MySQL/锁/悲观锁与乐观锁.html","title":"悲观锁与乐观锁","keywords":"","body":"悲观锁与乐观锁 概念 乐观锁（乐观并发控制）和悲观锁（悲观并发控制）是并发控制主要采用的技术手段。 可认为是一种思想。针对不同的业务场景，应选用不同的并发控制。 不要将其与锁机制（行锁、表锁、排它锁、共享锁）混为一谈 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作（一开始的时候就上锁） 应用场景：数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 例子：Java synchronized属于悲观锁的一种实现 乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性，若其他事务有更新的话，正在提交的事务进行进行回滚。 应用场景：读多写少，可提高吞吐量 实现方式：（1）数据版本（version）；（2）时间戳（timestamp） 例子：Java中的atomic包，AtomicInteger通过CAS操作实现线程安全的自增 MySQL中使用 MySQL InnoDB中使用悲观锁 首先关闭MySQL数据库的自动提交属性，set autocommit=0; //0.开始事务 begin; //1.查询出商品信息 select status from t_goods where id=1 for update; //2.根据商品信息生成订单 insert into t_orders (id,goods_id) values (null,1); //3.修改商品status为2 update t_goods set status=2; //4.提交事务 commit; 在查询语句中，使用select ... for update的方式，通过开启排它锁的方式实现悲观锁。 但需要注意，InnoDB 默认行级锁，行级锁是基于索引的，如果SQL语句未用到索引是不会使用行级锁的，会使用表级锁把整张表锁住。 优点： 为数据处理的安全提供保证 缺点： 因加锁，数据库产生额外开销 增加产生死锁的机会 若在只读型事务处理中由于不会产生冲突，没必要使用锁，会增加系统负载，降低并行性 使用版本号实现乐观锁 使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 1.查询出商品信息 select (status,status,version) from t_goods where id=#{id} 2.根据商品信息生成订单 3.修改商品status为2 update t_goods set status=2,version=version+1 where id=#{id} and version=#{version}; 具体案例 考虑电商系统中的下单流程，商品的库存量是固定的，如何保证商品数量不超卖？ 其实需要保证数据一致性：某个人点击秒杀后系统中查出来的库存量和实际扣减库存时库存量的一致性就可以。 假设，MySQL数据库中商品库存表tb_product_stock 结构定义如下： CREATE TABLE `tb_product_stock` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增ID', `product_id` bigint(32) NOT NULL COMMENT '商品ID', `number` INT(8) NOT NULL DEFAULT 0 COMMENT '库存数量', `create_time` DATETIME NOT NULL COMMENT '创建时间', `modify_time` DATETIME NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `index_pid` (`product_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品库存表'; 对应的POJO类： class ProductStock { private Long productId; //商品id private Integer number; //库存量 public Long getProductId() { return productId; } public void setProductId(Long productId) { this.productId = productId; } public Integer getNumber() { return number; } public void setNumber(Integer number) { this.number = number; } } 不考虑并发的情况下，更新库存代码如下： /** * 更新库存(不考虑并发) * @param productId * @return */ public boolean updateStockRaw(Long productId){ ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId}\", productId); if (product.getNumber() > 0) { int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId}\", productId); if(updateCnt > 0){ //更新库存成功 return true; } } return false; } 多线程并发情况下，会存在超卖的可能。 悲观锁 /** * 更新库存(使用悲观锁) * @param productId * @return */ public boolean updateStock(Long productId){ //先锁定商品库存记录 ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId} FOR UPDATE\", productId); if (product.getNumber() > 0) { int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId}\", productId); if(updateCnt > 0){ //更新库存成功 return true; } } return false; } 乐观锁 /** * 下单减库存 * @param productId * @return */ public boolean updateStock(Long productId){ int updateCnt = 0; while (updateCnt == 0) { ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId}\", productId); if (product.getNumber() > 0) { updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId} AND number=#{number}\", productId, product.getNumber()); if(updateCnt > 0){ //更新库存成功 return true; } } else { //卖完啦 return false; } } return false; } 使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。 我们的目标是确保库存不能被扣为负数，修改成 UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId} AND number > 0; 效率会改善 参考文献 深入理解乐观锁与悲观锁 MySQL 乐观锁与悲观锁 "}}