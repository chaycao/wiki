{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 用GitBook制作的个人wiki，用于整理知识 "},"JavaSE/":{"url":"JavaSE/","title":"语法","keywords":"","body":"JavaSE "},"JavaSE/语法/foreach.html":{"url":"JavaSE/语法/foreach.html","title":"foreach","keywords":"","body":"foreach foreach 在 jdk1.5 加入，当作 for 语法的一个增强。 能使用的类型：数组、java.lang.Iterable 数组：转换为对数组中每个元素的循环引用 Iterable：调用Iterator()返回的迭代器hasNext()、next()遍历 "},"JavaSE/语法/反射.html":{"url":"JavaSE/语法/反射.html","title":"反射","keywords":"","body":"反射 概念 程序在运行时可以访问、检查、修改它本身状态或行为的一种能力。用比喻来说就是，程序在运行的时候能够“观察”并且修改自己的行为。 原理 // 类的装载、链接、初始化 Class clz = Class.forName(\"ClassA\"); Object instance = clz.newInstance(); // 从 class 对象中获取到 method 方法，执行反射调用 Method method = clz.getMethod(\"myMethod\", String.class); method.invoke(instance, \"abc\",\"efg\"); newInstance()：反射调用了方法 Method.invoke()：调用 native 方法 或 字节码组装 invoke原理： Class 对象维护有一份该类所有的 Method、Field、Constructor，被称作根对象。 每次 getMethod 获取的 Method 对象持有根对象的引用，为了避免每次创建 Method 对象时进行初始化（重量级成员 MethodAccessor，所有Method 共享根对象的 MethodAccessor），每次创建时会调用根对象的 copy 方法。 调用 Method.invoke()，先进行访问权限检查，再获取 MethodAccessor 对象，并调用 MethodAccessor.invoke() 方法。 MethodAccessor 由 ReflectionFactory 创建。创建机制采用 inflation（可由JVM参数noInflation控制是否采用）： 当方法的累积调用次数 若大于，则创建由字节码组装的 MethodAccessorImpl 性能：通过JNI（Java Native Interface）调用native方法初始化更快，但对优化有阻碍作用随着调用次数增多，使用拼装的字节码可以直接以Java调用的方式实现反射，发挥JIT的优化作用 Java反射调用比普通调用慢，原因： Java的invoke方法传递Object、Object[]，对于基本类型需要装箱、拆箱，产生大量额外对象和内存开销，频繁促发GC 编译器难以对动态调用的代码提前做优化，如方法内联 反射需要检索类和方法，有一定时间开销 "},"JavaSE/语法/多态.html":{"url":"JavaSE/语法/多态.html","title":"多态","keywords":"","body":"多态 概念 允许不同子类型的对象对同一消息做出不同响应，也就是用同样的对象引用调用同样的方法但做了不同的事。 编译时多态：方法重载（overload，用于一个类内实现若干重载的方法，这些方法名称相同而参数形式不同） 运行时多态：方法重写（覆盖，override，用于子类继承父类时，重新实现父类中的方法） 原理 Java的方法调用动态绑定的实现主要依赖于方法表（这里的方法表 指的是虚方法表）。表中每一项都是指向相应方法的指针。其构造如下：方法表中最先存放Object类的方法，接着父类的方法，最后该类本身的方法。 继承：若子类覆盖了父类方法，则子类和父类的同名方法共享一个方法表项，被认为是父类的方法。由于方法的排列特性（Object--父类--子类），使得方法表的偏移量总是固定。（这里相当于是种优化，避免遍历） 在调用方法时： （1）首先查找常量池，找到方法的Class，再得到方法表中的该方法的偏移量 （2）调用对象引用偏移位置的方法接口：不能采用固定偏移量，需要遍历类的方法表查找 通过继承和接口的多态实现有所不同。继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。 接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。 JVM 首先查看 Party 的常量池索引为 12 的条目（应为 CONSTANT_Methodref_info 类型，可视为方法调用的符号引用），进一步查看常量池（CONSTANT_Class_info，CONSTANT_NameAndType_info ，CONSTANT_Utf8_info）可得出要调用的方法是 Person 的 speak 方法（注意引用 girl 是其基类 Person 类型），查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。 "},"并发/":{"url":"并发/","title":"并发","keywords":"","body":"并发 "},"JavaSE/并发/ThreadLocal.html":{"url":"JavaSE/并发/ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 作用 提供线程内的局部变量，可减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。 实现原理 每个 Thread 维护一个 ThreadLocalMap 映射表，该表的 key 为 ThreadLocal 实例，value 为需要存储的 Object。 即，ThreadLocal本身不存储值，只作为 key 让线程从 ThreadLocalMap 获取value。 图中的虚线表示 ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key（ThreadLocal 若无强引用，会在GC时被回收）。 为什么不使用强引用 当 ThreadLocal Ref 的对象被回收时，ThreadLocalMap 仍持有 ThreadLocal 强引用，若没有手动删除，会导致 Entry 内存泄漏。 隐患——内存泄漏 当 ThreadLocal 无强引用时，会在GC时被回收。则 ThreadLocalMap 中会出现 key 为 null 的 Entry，则无法访问该 Entry 的 value。若线程不结束，则 value 存在一条强引用链：Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value，将无法回收，造成内存泄露。 ThreadLocal 针对上面情况，已有防护措施：在 ThreadLocal 的 get()、set()、remove()的时候会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。 但是！仍然可能内存泄漏： 使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期。 分配了 ThreadLocal，但不调用get()、set()、remove。 内存泄漏的根本原因：ThreadLcoalMap 的生命周期与 Thread 一样长。 使用建议 每次使用完 ThreadLocal，调用remove()方法，清除数据。 "},"JavaSE/并发/BlockingQueue.html":{"url":"JavaSE/并发/BlockingQueue.html","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue 继承 Queue 接口。 提供三个添加元素方法： 方法 效果 add 添加成功返回True，添加失败返回抛出 IllegalStateException 异常 offer 添加成功返回True，添加失败返回 False put 若容量满了会阻塞直到 提供三个删除元素方法： 方法 效果 poll 删除队列头部元素，并返回元素，若队列为空，返回null remove 基于对象找到元素，并删除。成功返回True，失败返回False take 删除队列头部元素，若队列为空，则阻塞直到队列有元素 常用阻塞队列： ArrayBlockingQueue：基于循环数组，规定大小，FIFO顺序 LinkedBlockingQueue：基于单向链表，大小不定，FIFO顺序 PriorityBlockingQueue：基于单向链表，大小不定，按对象的自然排序或其构造函数的Comparator决定的顺序 LinkedBlockDeque：基于双向链表的双向队列，大小不定 ArrayBlockingQueue的原理 使用一个可重入锁和该锁生成的两个条件对象进行并发控制（classic two-condition algorithm） final ReentrantLock lock; private final Condition notEmpty; private final Condition notFull; LinkedBlockingQueue的原理 使用放锁、拿锁，两个锁实现阻塞（\"two lock queue\" algorithm） 由于有两个锁，所以添加数据和删除数据可并行进行。 不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的同时如果容量还没满，也会唤醒阻塞的线程。 private final ReentrantLock takeLock = new ReentrantLock(); private final Condition notEmpty = takeLock.newCondition(); private final ReentrantLock putLock = new ReentrantLock(); private final Condition notFull = putLock.newCondition(); "},"JNI/JNI.html":{"url":"JNI/JNI.html","title":"JNI","keywords":"","body":"JNI "},"Python/环境/":{"url":"Python/环境/","title":"环境","keywords":"","body":"环境 "},"Python/环境/包导出.html":{"url":"Python/环境/包导出.html","title":"包导出","keywords":"","body":"包导出 pip导出 pip freeze > requirements.txt pip wheel -r requirements.txt pip install --use-wheel --no-index --find-links=wheelhouse -r requirements.txt "}}