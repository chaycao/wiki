{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 用GitBook制作的个人wiki，用于整理知识 "},"src/JavaSE/":{"url":"src/JavaSE/","title":"语法","keywords":"","body":"JavaSE "},"src/JavaSE/语法/foreach.html":{"url":"src/JavaSE/语法/foreach.html","title":"foreach","keywords":"","body":"foreach foreach 在 jdk1.5 加入，当作 for 语法的一个增强。 能使用的类型：数组、java.lang.Iterable 数组：转换为对数组中每个元素的循环引用 Iterable：调用Iterator()返回的迭代器hasNext()、next()遍历 "},"src/JavaSE/语法/反射.html":{"url":"src/JavaSE/语法/反射.html","title":"反射","keywords":"","body":"反射 概念 程序在运行时可以访问、检查、修改它本身状态或行为的一种能力。用比喻来说就是，程序在运行的时候能够“观察”并且修改自己的行为。 作用： 获取对象的类信息 获取类的访问修饰符、成员、方法、构造函数、超类信息 检查属于接口的常量和方法声明 创建运行期加载的类的实例 获取并设置一个对象的成员，甚至这个成员的名字在运行期才知道 检测一个在运行期才知道名字的对象的方法 原理 // 类的装载、链接、初始化 Class clz = Class.forName(\"ClassA\"); Object instance = clz.newInstance(); // 从 class 对象中获取到 method 方法，执行反射调用 Method method = clz.getMethod(\"myMethod\", String.class); method.invoke(instance, \"abc\",\"efg\"); newInstance()：反射调用了方法 Method.invoke()：调用 native 方法 或 字节码组装 invoke原理： Class 对象维护有一份该类所有的 Method、Field、Constructor，被称作根对象。 每次 getMethod 获取的 Method 对象持有根对象的引用，为了避免每次创建 Method 对象时进行初始化（重量级成员 MethodAccessor，所有Method 共享根对象的 MethodAccessor），每次创建时会调用根对象的 copy 方法。 调用 Method.invoke()，先进行访问权限检查，再获取 MethodAccessor 对象，并调用 MethodAccessor.invoke() 方法。 MethodAccessor 由 ReflectionFactory 创建。创建机制采用 inflation（可由JVM参数noInflation控制是否采用）： 当方法的累积调用次数 若大于，则创建由字节码组装的 MethodAccessorImpl 性能：通过JNI（Java Native Interface）调用native方法初始化更快，但对优化有阻碍作用随着调用次数增多，使用拼装的字节码可以直接以Java调用的方式实现反射，发挥JIT的优化作用 Java反射调用比普通调用慢，原因： Java的invoke方法传递Object、Object[]，对于基本类型需要装箱、拆箱，产生大量额外对象和内存开销，频繁促发GC 编译器难以对动态调用的代码提前做优化，如方法内联 反射需要检索类和方法，有一定时间开销 "},"src/JavaSE/语法/多态.html":{"url":"src/JavaSE/语法/多态.html","title":"多态","keywords":"","body":"多态 概念 允许不同子类型的对象对同一消息做出不同响应，也就是用同样的对象引用调用同样的方法但做了不同的事。 编译时多态：方法重载（overload，用于一个类内实现若干重载的方法，这些方法名称相同而参数形式不同） 运行时多态：方法重写（覆盖，override，用于子类继承父类时，重新实现父类中的方法） 原理 Java的方法调用动态绑定的实现主要依赖于方法表（这里的方法表 指的是虚方法表）。表中每一项都是指向相应方法的指针。其构造如下：方法表中最先存放Object类的方法，接着父类的方法，最后该类本身的方法。 继承： 若子类覆盖了父类方法，则子类和父类的同名方法共享一个方法表项，被认为是父类的方法。由于方法的排列特性（Object--父类--子类），使得方法表的偏移量总是固定。（这里相当于是种优化，避免遍历） 在调用方法时： （1）首先查找常量池，找到方法的Class，再得到方法表中的该方法的偏移量 （2）调用对象引用偏移位置的方法 接口：不能采用固定偏移量，需要遍历类的方法表查找 通过继承和接口的多态实现有所不同。 继承：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。 接口：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。 JVM 首先查看 Party 的常量池索引为 12 的条目（应为 CONSTANT_Methodref_info 类型，可视为方法调用的符号引用），进一步查看常量池（CONSTANT_Class_info，CONSTANT_NameAndType_info ，CONSTANT_Utf8_info）可得出要调用的方法是 Person 的 speak 方法（注意引用 girl 是其基类 Person 类型），查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15（offset），这就是该方法调用的直接引用。 "},"src/JavaSE/并发/":{"url":"src/JavaSE/并发/","title":"并发","keywords":"","body":"并发 "},"src/JavaSE/并发/ThreadLocal.html":{"url":"src/JavaSE/并发/ThreadLocal.html","title":"ThreadLocal","keywords":"","body":"ThreadLocal 作用 是线程内的局部变量，只能被当前线程访问，其他线程无法访问和修改。可减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。 实现原理 每个 Thread 维护一个 ThreadLocalMap 映射表，该表的 key 为 ThreadLocal 实例，value 为需要存储的 Object。 即，ThreadLocal本身不存储值，只作为 key 让线程从 ThreadLocalMap 获取value。 图中的虚线表示 ThreadLocalMap 使用 ThreadLocal 的弱引用作为 key（ThreadLocal 若无强引用，会在GC时被回收）。 为什么不使用强引用 当 ThreadLocal Ref 的对象被回收时，ThreadLocalMap 仍持有 ThreadLocal 强引用，若没有手动删除，会导致 Entry 内存泄漏。 隐患——内存泄漏 当 ThreadLocal 无强引用时，会在GC时被回收。则 ThreadLocalMap 中会出现 key 为 null 的 Entry，则无法访问该 Entry 的 value。若线程不结束，则 value 存在一条强引用链：Thread Ref -> Thread -> ThreadLocalMap -> Entry -> value，将无法回收，造成内存泄露。 ThreadLocal 针对上面情况，已有防护措施：在 ThreadLocal 的 get()、set()、remove()的时候会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。 但是！仍然可能内存泄漏： 使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期。 分配了 ThreadLocal，但不调用get()、set()、remove。 内存泄漏的根本原因：ThreadLcoalMap 的生命周期与 Thread 一样长。 使用建议 每次使用完 ThreadLocal，调用remove()方法，清除数据。 参考 理解Java中的ThreadLocal 深入分析 ThreadLocal 内存泄漏问题 "},"src/JavaSE/并发/BlockingQueue.html":{"url":"src/JavaSE/并发/BlockingQueue.html","title":"BlockingQueue","keywords":"","body":"BlockingQueue BlockingQueue 继承 Queue 接口。 提供三个添加元素方法： 方法 效果 add 添加成功返回True，添加失败返回抛出 IllegalStateException 异常 offer 添加成功返回True，添加失败返回 False put 若容量满了会阻塞直到 提供三个删除元素方法： 方法 效果 poll 删除队列头部元素，并返回元素，若队列为空，返回null remove 基于对象找到元素，并删除。成功返回True，失败返回False take 删除队列头部元素，若队列为空，则阻塞直到队列有元素 常用阻塞队列： ArrayBlockingQueue：基于循环数组，规定大小，FIFO顺序 LinkedBlockingQueue：基于单向链表，大小不定，FIFO顺序 PriorityBlockingQueue：基于单向链表，大小不定，按对象的自然排序或其构造函数的Comparator决定的顺序 LinkedBlockDeque：基于双向链表的双向队列，大小不定 ArrayBlockingQueue的原理 使用一个可重入锁和该锁生成的两个条件对象进行并发控制（classic two-condition algorithm） final ReentrantLock lock; private final Condition notEmpty; private final Condition notFull; LinkedBlockingQueue的原理 使用放锁、拿锁，两个锁实现阻塞（\"two lock queue\" algorithm） 由于有两个锁，所以添加数据和删除数据可并行进行。 不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的同时如果容量还没满，也会唤醒阻塞的线程。 private final ReentrantLock takeLock = new ReentrantLock(); private final Condition notEmpty = takeLock.newCondition(); private final ReentrantLock putLock = new ReentrantLock(); private final Condition notFull = putLock.newCondition(); "},"src/JavaSE/JNI/JNI.html":{"url":"src/JavaSE/JNI/JNI.html","title":"JNI","keywords":"","body":"JNI 概念 JNI（Java Native Interface） 是Java平台的一部分，可以实现与其他语言（如C、C++）进行交互 JNI 是完善 Java 功能的一个重要功能： JVM 封装了各种操作系统的差异性，可使得 Java 程序跨平台 JNI 提供了 Java 程序与操作系统相关功能函数交互的接口 应用场景 程序对时间敏感或对性能要求特别高，有必要用更底层的语言（如汇编、C、C++） 在已有现成的用其他语言已完成的功能时，需要用 Java 去调用 在需要用到 Java 标准平台不具备的依赖于操作系统的特性时 原理 调用过程示例图 使用步骤 在 Java 类中声明 Native 方法，类中同时需要加载使用的动态库 用 javah 程序，将上步中的 class 文件生成头文件 javah -jni XXX javah 程序统一了 Java 中的 native 方法、头文件中的函数名和动态库中的函数实现之间的对应关系 用其他语言（如C、C++）实现上述头文件中的函数，生成动态库，供 Java 程序使用 发布 Java 和动态库 实例 环境：Ubuntu 10.4.2 LTS系统 package com.magc.jni; public class HelloWorld { static { System.loadLibrary(\"Hello\"); } public native void DisplayHello(); public static void main(String[] args) { new HelloWorld().DisplayHello(); } } 进入src目录下，编译该JAVA类， javac ./com/magc/jni/HelloWorld.java 在该HelloWorld.java所在目录下生成HelloWorld.class 然后使用javah生成头文件， javah -jni com.magc.jni.HelloWorld 在当前目录下生成com_magc_jni_HelloWorld.h头文件，此文件供C、C++程序来引用并实现其中的函数 /* DO NOT EDIT THIS FILE - it is machine generated */ #include /* Header for class com_magc_jni_HelloWorld */ #ifndef _Included_com_magc_jni_HelloWorld #define _Included_com_magc_jni_HelloWorld #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_magc_jni_HelloWorld * Method: DisplayHello * Signature: ()V */ JNIEXPORT void JNICALL Java_com_magc_jni_HelloWorld_DisplayHello (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 注：1)、此头文件是不需要用户编译的，直接供其它C、C++程序引用。 2)、此头文件中的Java_com_magc_jni_HelloWorld_DisplayHello(JNIEnv *, jobject)方法，是将来与动态链接库交互的接口，并需要名字保持一致。 #include #include \"com_magc_jni_HelloWorld.h\" #include JNIEXPORT void JNICALL Java_com_magc_jni_HelloWorld_DisplayHello (JNIEnv *env, jobject obj) { printf(\"From jni_helloworldImpl.cpp :\"); printf(\"Hello world ! \\n\"); return; } 此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。 编译生成动态库 libHello.so g++ -shared -I /usr/lib/jvm/java-6-openjdk/include jni_helloworldImpl.cpp -o libHello.so 成功后，便会在当前目录下生成动态链接库libHello.so文件。 有了具体实现的动态库后，就可以运行 JAVA 调用 JNI程序类的 native 方法了。 java -Djava.library.path=. com.magc.jni.HelloWorld "},"src/JVM/运行时数据区域/运行时数据区域.html":{"url":"src/JVM/运行时数据区域/运行时数据区域.html","title":"运行时数据区域","keywords":"","body":"运行时数据区域 程序计数器 记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为零）。 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小： java -Xss=512M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈 与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 堆 所有对象实例都在这里分配内存。 是垃圾收集的主要区域（\"GC 堆\"），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块： 新生代（Young Generation） 老年代（Old Generation） 永久代（Permanent Generation） 当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间： Eden From Survivor To Survivor Java 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 java -Xms=1M -Xmx=2M HackTheJava 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK 1.8 之后，取消了永久代，用 metaspace（元数据）区替代。 运行时常量池 运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。这部分常量也会被放入运行时常量池。 直接内存 在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 二、垃圾收集 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。 判断一个对象是否可回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 public class ReferenceCountingGC { public Object instance = null; public static void main(String[] args) { ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; } } 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 2. 可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 3. 引用类型 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。 Java 具有四种强度不同的引用类型。 （一）强引用 被强引用关联的对象不会被垃圾收集器回收。 使用 new 一个新对象的方式来创建强引用。 Object obj = new Object(); （二）软引用 被软引用关联的对象，只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 Object obj = new Object(); SoftReference sf = new SoftReference(obj); obj = null; // 使对象只被软引用关联 （三）弱引用 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。 使用 WeakReference 类来实现弱引用。 Object obj = new Object(); WeakReference wf = new WeakReference(obj); obj = null; WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。 private static class Entry extends WeakReference implements Map.Entry Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。 public final class ConcurrentCache { private final int size; private final Map eden; private final Map longterm; public ConcurrentCache(int size) { this.size = size; this.eden = new ConcurrentHashMap<>(size); this.longterm = new WeakHashMap<>(size); } public V get(K k) { V v = this.eden.get(k); if (v == null) { v = this.longterm.get(k); if (v != null) this.eden.put(k, v); } return v; } public void put(K k, V v) { if (this.eden.size() >= size) { this.longterm.putAll(this.eden); this.eden.clear(); } this.eden.put(k, v); } } （四）虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 Object obj = new Object(); PhantomReference pf = new PhantomReference(obj); obj = null; 4. 方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 5. finalize() finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。 垃圾收集算法 1. 标记 - 清除 将需要存活的对象进行标记，然后清理掉未被标记的对象。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 2. 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 4. 分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 1. Serial 收集器 Serial 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器 与 ParNew 一样是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。 4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。 G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 更详细内容请参考：Getting Started with the G1 Garbage Collector 8. 比较 收集器 串行/并行/并发 新生代/老年代 收集算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 串行 + 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 串行 + 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 串行 + 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并行 + 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并行 + 并发 新生代 + 老年代 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略 对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 1. Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 2. 内存分配策略 （一）对象优先在 Eden 分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 （二）大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 （三）长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 （四）动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 （五）空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 3. Full GC 的触发条件 对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： （一）调用 System.gc() 此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。 （二）老年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 （三）空间分配担保失败 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 （四）JDK 1.7 及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 （五）Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 三、类加载机制 类是在运行期间动态加载的。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 类初始化时机 虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随着发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 System.out.println(ConstClass.HELLOWORLD); 类加载过程 包含了加载、验证、准备、解析和初始化这 5 个阶段。 1. 加载 加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用是 Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ... 2. 验证 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。 字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。 符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 3. 准备 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次） 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 public static final int value = 123; 4. 解析 将常量池的符号引用替换为直接引用的过程。 5. 初始化 初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 () 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” } static int i = 1; } 与类的构造函数（或者说实例构造器 ()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 () 方法运行之前，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： static class Parent { public static int A = 1; static { A = 2; } } static class Sub extends Parent { public static int B = A; } public static void main(String[] args) { System.out.println(Sub.B); // 输出结果是父类中的静态变量 A 的值，也就是 2。 } () 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 () 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类加载器 实现类的加载动作。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。 1. 类与类加载器 两个类相等：类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 2. 类加载器分类 从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 3. 双亲委派模型 应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 （一）工作过程 一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。 （二）好处 使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。正因为 rt.jar 中的 Object 优先级更高，因为程序中所有的 Object 都是这个 Object。 （三）实现 以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 public abstract class ClassLoader { // The parent class loader for delegation private final ClassLoader parent; public Class loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } } protected Class findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } } 4. 自定义类加载器实现 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 类的方法 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，而是通过重写 findClass() 方法。 public class FileSystemClassLoader extends ClassLoader { private String rootDir; public FileSystemClassLoader(String rootDir) { this.rootDir = rootDir; } protected Class findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { String path = classNameToPath(className); try { InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; } } 四、JVM 参数 GC 优化配置 配置 描述 -Xms 初始化堆内存大小 -Xmx 堆内存最大值 -Xmn 新生代大小 -XX:PermSize 初始化永久代大小 -XX:MaxPermSize 永久代最大容量 GC 类型设置 配置 描述 -XX:+UseSerialGC 串行垃圾回收器 -XX:+UseParallelGC 并行垃圾回收器 -XX:+UseConcMarkSweepGC 并发标记扫描垃圾回收器 -XX:ParallelCMSThreads= 并发标记扫描垃圾回收器 = 为使用的线程数量 -XX:+UseG1GC G1 垃圾回收器 java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar "},"src/JVM/垃圾回收/垃圾回收.html":{"url":"src/JVM/垃圾回收/垃圾回收.html","title":"垃圾回收","keywords":"","body":"垃圾回收 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。 判断一个对象是否可回收 1. 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 缺点：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 public class ReferenceCountingGC { public Object instance = null; public static void main(String[] args) { ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; } } Java 虚拟机不使用引用计数算法。 2. 可达性分析算法 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 3. 引用类型 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。 Java 具有四种强度不同的引用类型。 （一）强引用 被强引用关联的对象不会被垃圾收集器回收。 使用 new 一个新对象的方式来创建强引用。 Object obj = new Object(); （二）软引用 被软引用关联的对象，只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 Object obj = new Object(); SoftReference sf = new SoftReference(obj); obj = null; // 使对象只被软引用关联 （三）弱引用 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。 使用 WeakReference 类来实现弱引用。 Object obj = new Object(); WeakReference wf = new WeakReference(obj); obj = null; WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。 private static class Entry extends WeakReference implements Map.Entry Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。 public final class ConcurrentCache { private final int size; private final Map eden; private final Map longterm; public ConcurrentCache(int size) { this.size = size; this.eden = new ConcurrentHashMap<>(size); this.longterm = new WeakHashMap<>(size); } public V get(K k) { V v = this.eden.get(k); if (v == null) { v = this.longterm.get(k); if (v != null) this.eden.put(k, v); } return v; } public void put(K k, V v) { if (this.eden.size() >= size) { this.longterm.putAll(this.eden); this.eden.clear(); } this.eden.put(k, v); } } （四）虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 Object obj = new Object(); PhantomReference pf = new PhantomReference(obj); obj = null; 4. 方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 5. finalize() finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。 垃圾收集算法 1. 标记 - 清除 将需要存活的对象进行标记，然后清理掉未被标记的对象。 缺点： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 2. 标记 - 整理 标记存活的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 4. 分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将 Java 堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清理 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 1. Serial 收集器 Serial 翻译为串行，垃圾收集和用户程序不能同时执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 优点：简单高效。对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器 与 ParNew 一样是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。 4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。 G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 更详细内容请参考：Getting Started with the G1 Garbage Collector 8. 比较 收集器 串行/并行/并发 新生代/老年代 收集算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 串行 + 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 串行 + 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 串行 + 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并行 + 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并行 + 并发 新生代 + 老年代 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略 对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 1. Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 2. 内存分配策略 （一）对象优先在 Eden 分配 大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 （二）大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 （三）长期存活的对象进入老年代 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 （四）动态对象年龄判定 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 （五）空间分配担保 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 3. Full GC 的触发条件 对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： （一）调用 System.gc() 此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。 （二）老年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 （三）空间分配担保失败 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 （四）JDK 1.7 及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 （五）Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 "},"src/面试真题/Java.html":{"url":"src/面试真题/Java.html","title":"Java","keywords":"","body":"1. HashMap什么情况下发生死链 JDK1.8之前，并发resize()的时候可能会发生死链。 参考 2. HashMap HashMap的特性？ HashMap 存储键值对，实现快速存取数据；允许null键\\值；非同步；不保证有序 HashMap的原理，内部数据结构？ 基于hashing的原理，jdk1.8之前底层使用哈希表（数组+链表）实现。jdk1.8之后，当链表长度大于8时，将链表转换成红黑树。 HashMap中的最重要两个方法put、get put方法的原理：传入k，v，通过取hashcode，高位参与运算、取模运算三步，获得bucket位置，进行存储，如果没有碰撞直接放bucket里，如果碰撞，以链表形式存在buctets后，如果节点已经存在就替换oldvalue。当hashmap的bucket占用情况超过capacity*load_factor则，通过resize方法扩容为2倍。 get方法的原理：传入k，通过取hashcode，高位参与运算、取模运算三步，获得bucket位置，并进一步调用equals方法确定键值对。 当两个对象的hashcode相同会发生什么？ 若两个对象的hashcode相同，则他们的bucket位置相同，会发生碰撞。 有哪些hash的实现方式？ 直接定址法：取k的某个线性函数值为散列地址。 数字分析法：提取关键字k中取值比较均匀的数字作为哈希地址。例如，生日使用月份和日期构成散列地址。 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。 伪随机数法：采用一个伪随机数当作哈希函数。 有哪些hash冲突解决办法？ 开放地址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。 建立公共溢出表：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。 为什么String、Integer适合作为键？ 已重写了equals()和hashCode()。（让不相等的对象返回不同的hashcode值） 具有不可变性，可防止键值的改变，线程安全 HashMap与HashTable区别？ 线程安全性。HashTable中几乎所有函数是同步的，所以它是线程安全的。HashMap是线程不安全的。 NULL值。HashMap的key、value都可为null，Hashtable都不可为null 容器的初始值和扩容方式。HashMap默认16，扩容 （原始容量2）,；HashTable默认11，扩容 （原始容量 2+1） HashMap继承于AbstractMap，HashTable继承于Dictionary hash算法。HashMap自定义的哈希算法；HashTable直接采用key的hashCode()； 速度。单线程环境下HashMap更快 让HashMap同步 Collections.synchronizeMap() 3. 多线程顺序执行 （1） 有A、B、C、D四个线程，A线程输出A, B线程输出B, C线程输出C，D线程输出D，要求, 同时启动四个线程, 按顺序输出ABCD 答：通过Thread.join()方法，B、C、D分别持有A、B、C的引用，并且在输出前调用持有线程的join方法，等待线程执行完毕，再输出。 package thread; public class TestThread1 { public static void main(String[] args) { // 线程A final Thread a = new Thread(new Runnable() { @Override public void run() { System.out.println(\"A\"); } }); // 线程B final Thread b = new Thread(new Runnable() { @Override public void run() { try { // 执行b线程之前，加入a线程,让a线程执行 a.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"B\"); } }); // 线程C final Thread c = new Thread(new Runnable() { @Override public void run() { try { // 执行c线程之前，加入b线程,让b线程执行 b.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"C\"); } }); // 线程D Thread d = new Thread(new Runnable() { @Override public void run() { try { // 执行d线程之前，加入c线程,让c线程执行 c.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"D\"); } }); // 启动四个线程 a.start(); b.start(); c.start(); d.start(); } } （2） 有A,B,C三个线程, A线程输出A, B线程输出B, C线程输出C。要求, 同时启动三个线程, 按顺序输出ABC, 循环10次 使用ReentrantLock控制并发,并使用一个state整数来判断应哪个线程执行。 public class Test { private static ReentrantLock lock = new ReentrantLock(); private static int state = 0; static class A extend Thread() { @Override public void run() { lock.lock(); for (int i = 0; i 4. hashCode()与equals() equals()方法用来判断两个对象是否相等，Object默认比较对象地址 hashCode()方法用来获取哈希码，Object默认根据对象地址转换成一个整数 为什么重写equals()一定要重写hashCode()方法 这是因为HashMap等哈希表是由hashcode()定位要存放的位置，而equals()判断是否相等，这意味着逻辑上equals()相等，认为这两个对象相等则应该放在同一个桶中，所以hashcode()也需要相等。 hashCode的作用 用于查找，在HashMap、HashTable等散列表中用hashCode确定对象的存储地址。 5. Java内存模型 Java内存模型（JMM）是一种虚拟机规范，定义了多线程之间共享变量的可见性。采用的是共享内存模型，线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程读\\写共享变量的副本。 6. Object的公用方法 toString() equals() hashCode() wait()、notify()、notifyAll() clone() getClass() finalize() 7. String、StringBuffer、StringBuilder String：不可变对象，每次改变相当于生成新的String对象 StringBuffer：可变对象，线程安全 StringBuilder：可变对象，线程不安全，速度比StringBuffer快 8. 创建对象的方式 用 new 语句创建对象 反射，调用 java.lang.Class 或 java.lang.reflect.Constructor 类的 newInstance() 实例方法 调用对象的 clone() 方法 反序列化，通过 java.io.ObjectInputStream 对象的 readObject() 方法 1、2会调用构造函数 3 是在内存上对已有对象的影印，不会调用构造函数 4 是从文件中还原，不会调用构造函数 9. try里有return，finally是否执行 会执行，在return表达式之后执行，返回之前执行 finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。 参考 10. Exception与Error 联系： Error和Exception都继承于 Throwable 接口，RuntimeException 继承自 Exception Error和RuntimeException及其子类称为未检查异常（Unchecked exception），其他异常为受检查异常 区别： Error类， 指与虚拟机相关的问题，如系统崩溃、虚拟机错误、内存空间不足、栈溢出等，java.lang.StackOverFlowError、java.lang.OutOfMemoryError 编译器不检查 导致的应用程序中断，仅靠程序本身无法恢复和预防，建议让程序终止 Exception类 程序可以处理的异常，可以捕获且可能恢复 遇到这类异常，应该尽可能处理 运行时异常和受检查异常 运行时异常：Java编译器不检查，如果出现运行时异常，一定是程序问题，如除数为0、错误的类型转换、数组越界访问、试图访问空指针 受检查异常：如果没有try..catch或throws，编译不通过，不是程序本身错误，而是应用环境中出现的外部问题 11. Java面向对象的三个特征和含义 封装：把数据和方法绑定起来，对数据的访问只能通过已定义的接口，也就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口Java的四种访问控制符：public，default，protected，private 继承：从已有类得到继承信息创建新类的过程。提供继承信息的类称为父类；得到继承信息的类称为子类继承使变化中的软件系统具有一定的延续性，同时继承使封装程序中具有扩展性Java中的extends（用于基本类和抽象类）和implements（用于接口），extends单继承，implements不限 多态：允许不同子类型的对象对同一消息做出不同响应，也就是用同样的对象引用调用同样的方法但做了不同的事。分为 编译时多态：方法重载（overload，用于一个类内实现若干重载的方法，这些方法名称相同而参数形式不同） 运行时多态：方法重写（覆盖，override，用于子类继承父类时，重新实现父类中的方法） 12. Interface 与 Abstart 的区别 两者的特性： 抽象类：用来捕捉子类的通用特性。不能被实例化，只能作为子类的超类，被用来创建继承层级里子类的模板 接口：抽象方法的集合，像契约模式，若实现该接口，则必须确保使用接口中的方法对比： 参数 抽象类 接口 默认方法实现 可以 不可以 实现 extends关键字。若子类不是抽象类，需提供所有声明方法的实现 implements关键字。需提供所有声明方法的实现 构造器 可以有 可以有 访问修饰符 public、protected、default、private 默认public不可以其他 main方法 可以有 不可以 13. 静态内部类 与 非静态内部类 区别 静态内部类：不需要有指向外部类对象的引用；可以访问静态成员 非静态内部类：需要有指向外部类对象的引用；可以访问静态成员和非静态成员； 14. 多态的实现原理 参考 15. ThreadLocal的设计理念和作用 参考 16. foreach 效率 还是得看普通for里的具体操作 对于ArrayList，普通for快一点，减少了“解除语法糖”的操作 对于LinkedList，linkedlist.get(）每次都从头开始了，foreach就快很多， foreach能使用的类型：数组、java.lang.Iterable 数组：转化为对数组中每个元素的循环引用 Iterable接口，调用next()、hasNext()方法做循环遍历 17. 反射的实现原理 参考 18. synchronized synchronized 是Java中的关键字，可以控制多线程对共享资源的访问。在Java中每一个对象都可以作为锁 当synchronized作用于以下三种情况： 对于普通同步方法，锁是当前实例对象 对于静态同步方法，锁是当前类的Class对象 对于同步方法块，锁是Synchronized括号里配置的对象 实现原理： JVM 基于进入和退出 Monitor 对象来实现方法同步、代码块同步 代码块同步：使用 monitorenter、monitorexit 指令实现 方法同步：方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志辨别是否为同步方法 19. Socket 编程 服务端： 构建一个 ServerSocket 实例，指定本地端口，该 socket监听指定端口的连接请求 重复以下步骤： 调用 accept() 方法获得客户端的连接请求，通过 accept() 方法返回的 socket 实例，建立一个和客户端的新连接 通过返回的 socket 实例获取 InputStream 和 OutputStream 来读写数据 通过 close() 方法关闭 socket 连接 客户端： 构建 Socket 实例，通过制定的远程服务器和端口建立连接 通过 Socket 实例包含的 InputStream 和 OutputStream 来进行数据的读写 操作结束调用 socket 实例的 close 方法。 20. Java 读文件的几种方式 按字节读取 按字符读取 按行读取 随机读取 参考 21. 防止表单重复提交 1、场景一：在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交。 在网络比较慢的情况下，用户连续快速的点击多次提交按钮。 2、场景二：表单提交后用户点击【刷新】按钮导致表单重复提交。 用户点击了提交按钮，然后点击浏览器上的【刷新】按钮对form表单又进行一次提交。 3、场景三：用户提交表单后，点击浏览器的【后退】按钮回退到表单页面后进行再次提交 解决方案一：利用JavaScript防止表单重复提交。 在客户端的js代码中设置一个标识位，第一次提交后将标志位设置成true，或将提交按钮设置为不可用 解决方案二：利用Session防止表单重复提交 对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决，那么就在服务器端解决，在服务器端解决就需要用到session了。 具体的做法： 在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。 在下列情况下，服务器程序将拒绝处理用户提交的表单请求： 存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。 当前用户的Session中不存在Token(令牌)。 用户提交的表单数据中没有Token(令牌)。 参考 22. BIO、NIO、AIO BIO：同步阻塞 NIO：同步非阻塞 AIO：异步非阻塞 23. 获取方法参数名 在Java 8之前的版本，代码编译为class文件后，方法参数的类型是固定的，但参数名称却丢失了 ，为无意义的arg0、arg1 。 为了获得参数名，可通过以下两种方法获得： 通过注解 public User getUser(@Param(\"groupid\") String groupid, @Param(\"userid\") String userid) { ... } 从class文件中获取 javac默认不会生成本地变量表信息，需指定-g或-g:vars，从class文件中获取参数名信息，可使用第三方类库 asm、javassist等操作。 Java 8新特性，编译器保留方法参数名，使用-parameters参数编译 24. 线程池 概念：一种多线程处理方式，线程池维护多个线程，等待被分配任务 作用：限制系统中执行线程的数量 为什么使用线程池： 减少创建和销毁线程的数量，工作线程可被重复利用 可根据系统的承受能力，调整线程池中工作线程的数量 四个基本组成： 线程池管理器（ThreadPool）：用于创建并管理线程池 工作线程（PoolWorker）：线程池中线程可循环执行任务 任务接口（Task）：每个任务需实现的接口，以供工作线程调度任务的执行（任务入口，收尾工作，执行状态） 任务队列（TaskQueue）：存放未处理任务 Java线程池的实现类：ThreadPoolExecutor public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 线程池参数 corePoolSize：线程池的基本大小，当提交任务到线程池时，即使有其他空闲的基本线程也会创建线程。当基本线程数量达到corePoolSize则不再创建 maximumPoolSize：线程池允许创建的最大线程数。如果阻塞队列满了，并且已经创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。 keepAliveTime：线程活动保持时间。指工作线程空闲后，继续保持存活的时间。默认情况下，这个参数只有在线程数大于corePoolSize时才起作用（也可设置对核心线程起作用）。所以，如果任务很多，且每个任务的执行时间比较短，可以调大keepAliveTime，提高线程的利用率。 unit：保持时间的单位 workQueue：用来保存等待执行的任务的阻塞队列 ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO原则对元素进行排序。 LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序元素，吞吐量通常要高于ArrayBlockingQuene。 SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene。 priorityBlockingQuene：具有优先级的无界阻塞队列。 threadFactory：创建线程的工厂。可以通过自定义线程工厂给每个线程设置有意义的名称 rejectedExecutionHandler：饱和策略。当阻塞队列满了且没有空闲的工作线程，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略在默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。不过，线程池提供了4种策略： AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在的线程来运行任务。 DiscardOldestPolicy：丢弃阻塞队列中最近的一个任务，并执行当前任务。 DiscardPolicy：直接丢弃。 Executors Exectors是java线程池的工厂类，通过它可以快速初始化一个符合业务需求的线程池，主要提供了以下几种便捷的方式： 1.newFixedThreadPool：创建一个指定工作线程数的线程池，其中参数corePoolSize和maximumPoolSize相等，阻塞队列基于LinkedBlockingQuene。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); } 优点：提高程序效率和节省创建线程时所耗的开销 缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。 2.newCachedThreadPool：创建一个可缓存工作线程的线程池（工作线程默认存活时间1分钟）。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue()); } 该线程池有以下特点： 1、工作线程数量几乎没有上限，因为maximumPoolSize为Integer.MAX_VALUE（2147483647）。 2、如果长时间没有提交任务，且工作线程空闲了指定的时间，则该工作线程将自动终止。如果重新提交了任务，则线程池重新创建一个工作线程。 优点：在没有任务执行时，会释放工作线程，从而释放工作线程所占用的资源。 缺点：当提交新任务时，没有空闲线程时，又要创建新的工作线程，有一定的系统开销。另外一定要注意控制任务的数量，否则由于大量线程同时运行，很有会造成系统瘫痪。 3.newSingleThreadExecutor：创建一个只有单一工作线程的线程池。如果这个工作线程异常结束，会有另一个取代它。唯一的工作线程可以保证任务的顺序执行。 new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()) 4.newScheduledThreadPool：创建一个可以在指定时间内周期性的执行任务的线程池。在实际业务中常用的场景是周期性的同步数据。 任务提交 向线程池提交任务有两种： 1.execute()：用于提交不需要返回值的任务，这个方式无法判断任务是否执行成功。 executor.execute(runnableTask); 2.submit()：用于提交需要返回值的任务。线程池会返回一个Future对象，通过这个对象可以判断任务是否执行成功。 Future future = executor.submit(callableTask); 实现原理 线程池的运行状态： RUNNING ： 接受新任务并且处理已经进入阻塞队列的任务。 SHUTDOWN ： 不接受新任务，但是处理已经进入阻塞队列的任务。 STOP : 不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务。 TIDYING : 所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数 。 TERMINATED: terminated钩子函数已经运行完成。 当向线程池提交一个任务时，如图所示： 如果当前运行的线程数少于corePoolSize，则创建新的工作线程处理任务，否则进入步骤2。 如果线程池处于运行状态，则把任务放入BlockingQueue中，如果可用工作线程为0时，则创建新的工作线程，处理BlockingQueue的任务。 如果无法将任务加入到BlockingQueue，则创建新的线程处理任务，前提是目前运行的线程数小于maximumPoolSize，否则进入步骤4 任务被拒绝。 15. 抽象类与接口 相同点： 不能实例化 抽象类中可以包含非抽象的普通方法，接口中可以有非抽象的非抽象方法，比如default方法 都可以有静态成员变量 不同点： 抽象类可以有构造方法，接口中不能 抽象类可以有普通成员变量，接口中不能 抽象类的抽象方法的访问类型可以是public 、protected，但接口中的抽象方法只能是public 抽象类中可以包含静态方法，接口中不能 抽象类中静态成员变量的访问类型可以任意，接口中的变量只能是public static final类型 一个类可以实现多个接口，但只能继承一个抽象类。 抽象类里面的方法子类必须全部实现吗，可不可以有不实现的方法，接口呢？ 抽象类不一定，子类只会实现父类里的抽象方法，抽象类里可以有抽象方法也可以非抽象方法，子类不需要再去实现非抽象方法，如果子类一定要再次实现的话就叫做覆盖了 接口里的方法必须全部实现，因为接口里的方法都是抽象的，默认都是public abstract 抽象类的作用是什么，什么时候用到抽象类 封装（隐藏对象的属性和实现细节，仅对外公开接口） "},"src/面试真题/JVM.html":{"url":"src/面试真题/JVM.html","title":"JVM","keywords":"","body":"1. 内存泄露、内存溢出 内存泄露：指不再使用的对象，被某个对象持有该引用导致GC不能回收。 造成内存泄露的原因： 静态集合类。如HashMap、Vector，生命周期与程序一致，则容器中的对象在程序结束之前不能被释放。 连接资源未释放。如数据库连接、网络连接、IO连接等，当不再使用时，需要调用close方法来释放连接，只有连接关闭，GC才能回收。 变量不合理的作用域。变量定义的作用范围大于其使用范围；没有及时的把对象设置为null。 解决方案： 避免在循环中创建对象。 尽早释放无用对象的引用。 尽量少用静态变量。 使用字符串处理，避免使用String，改为使用StringBuffer或StringBuilder。 如何查找内存泄露？ 使用 Jconsole。 如果随着时间，内存大小持续增长，则说明系统存在内存泄露。 内存溢出：程序运行过程中无法申请到足够的内存。 内存溢出的几种情况（OOM）： 虚拟机栈和本地方法栈 溢出 堆 溢出 方法区 溢出 运行时常量池 溢出 导致内存溢出的原因： 内存中加载的数据量过大，如一次从数据库中加载过多数据 集合类中有对象的引用，使用后未清空，不能被GC 代码存在死循环或循环产生过多重复对象 启动参数内存值设定过小 解决办法： 修改JVM启动参数，直接增加内存 检查错误日志 使用内存查看工具动态查看内存使用情况 对代码分析，找出可能内存溢出的地方 2. Java的垃圾回收机制 Java的垃圾回收机制使得程序员在编写代码时不需要考虑内存管理。垃圾回收器作为守护线程运行，在不可预知的情况下对内存堆中的对象进行清理的回收。程序员不能实时的调用垃圾回收器进行垃圾回收。可以手动执行System.gc()通知GC运行，但并不保证GC一定会执行。 垃圾回收器的机制可以从三个方面讲述 （1）什么时候触发GC 当新生代中的eden区满了，会触发minor gc； 进行minor gc时，survivor区升到老年代的平均对象大于老年代剩余空间会触发full gc，或者小于时HandlePromotionFailure参数为false，强制full gc。 （2）哪些对象需要被回收 从GC Roots搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。 （3）如何回收 对于新生代使用复制算法，将Eden和from surivor中还活着的对象一次性复制到to surivor中，再清理掉Eden和From Survior空间。 对于老年代使用标记清除或标记整理算法。标记清除首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象，但是会产生大量不连续的内存碎片；标记整理的标记与标记清除相同，但不是直接回收对象，而是将所有存活的对象向一端移动，然后直接清理掉边界以外的内存 。 3. JVM内存分区 JVM内存被分为以下几个区域： （1）程序计数器：记录当前线程执行字节码指令的地址 （2）虚拟机栈：当方法执行时，会创建一个栈帧，存放局部变量表、操作数栈、方法出口等信息。 （3）本地方法栈：Native方法执行时使用，与虚拟机栈类似 （4）虚拟机堆：所有创建的对象都在堆中分配内存并初始化 （5）方法区：存放虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等信息 其中程序计数器、虚拟机栈、本地方法栈为线程私有。 为什么要分为堆和栈？ 逻辑清晰。栈表示逻辑，堆表示数据，各自有合适的内存管理方式，方便JVM调用和管理。 数据交互。栈帧彼此独立，堆中内容被栈帧共享。 4. 四种引用的特点和使用场景 强引用（StrongReference） 最普通的引用，垃圾回收器不会回收（内存不够也不会回收） 软引用（SoftReference） 内存够不回收，内存不够则回收（可与引用队列ReferenceQueue联合使用） 可用来实现内存敏感的高速缓存 弱引用（WeakReference） 无论内存是否足够，都会被回收（可与引用队列ReferenceQueue联合使用） 可用于Map中，引用占用空间较大的对象 虚引用（PhantomReference） get方法不能获得指向对象，必须与引用队列ReferenceQueue联合使用 用于跟踪垃圾回收过程 。当指向的对象回收后，被加入到引用队列，用作记录该引用指向的对象已被销毁。可用于在实现对象被回收前做清理操作，比finalize()更灵活 一个对象的引用类型有多个，如何判断它的可达性，规则（“单弱多强”）如下： 单条引用链的可达性以最弱的一个引用类型来决定 多条引用链的可达性以最强的一个引用类型来决定 5. GC Roots 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中静态成员引用的对象 方法区中常量引用的对象 6. 内存分配策略 优先分配在Eden区。如果Eden区空间不够，执行一次minor GC 大对象直接进入老年代。避免在Eden区和Survivor区之间发生大量内存拷贝 长期存活对象进入老年代。每经过一次minor GC，年龄加1，大于阈值（默认15），进入老年代 动态判断对象的年龄。Survivor区中相同年龄的所有对象大小大于Survivior空间的一半，则大于等于该年龄的对象直接进入老年代。 空间分配担保。每次进行minor GC，会计算Survivor区移至老年代的对象的平均大小。若这个值大于老年代的剩余大小则进行一次Full GC，如果小于，则检查HandlepromotionFailure设置，若为true则进行minor GC，若为false则Full GC。 7. 垃圾收集算法的原理和特点 参考 8. 垃圾收集器有哪些？CMS、G1的特点 参考 CMS（Concurrent Mark Sweep） 使用标记-清理算法，并发收集、低停顿 四个流程：初始标记、并发标记、重新标记、并发清除 缺点：吞吐量低、无法处理浮动垃圾、产生空间碎片 9. 减少GC的次数 对象不用时，最好显示置为null 少用system.gc() 少用静态变量 使用StringBuffer或StringBuilder，而不用String做字符串处理 分散对象创建或删除的时间 少用finalize函数 文件（如图片）可使用软引用类型 能用基本类型int、long，就不用包装类Integer、Long 增大-xmx 10. JVM常见启动参数 -Xms：设置堆的最小值 -Xmx：设置堆的最大值 -Xmn：设置新生代的大小 -Xss：设置每个线程的栈大小 -XX:NewSize：设置新生代的初始值 -XX:MaxNewSize：设置新生代的最大值 -XX:PermSize：设置永久代的初始值 -XX:MaxPermSize：设置永久代的最大值 -XX:SurvivorRatio：设置新生代中Eden区和Survivor区的大小比值 -XX:PretenureSizeThreshold：大于该值，直接分配在老年代 11. 常用内存调试工具 jps ：查看虚拟机进程情况，如进程ID jmap ：用于生成堆转储快照文件（某一时刻） jhat ：对生成的对转储快照文件进行分析 jstack ：用来生成线程快照（某一时刻）。用于定位线程长时停顿的原因（如死锁、死循环、等待IO） jstate ：虚拟机统计信息监视工具。如显示垃圾收集的情况，内存使用的情况。 jconsole ：内存监控，线程监控 12. 类加载机制 Java中类是在运行时动态加载的。 一、类的生命周期 包括7个阶段： 加载 验证 准备 解析 初始化 使用 卸载 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 二、类初始化时机 虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 System.out.println(ConstClass.HELLOWORLD); 三、类加载过程 包含了加载、验证、准备、解析和初始化这 5 个阶段。 加载 加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。 从网络中获取，这种场景最典型的应用是 Applet。 运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。 ... 验证 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。 字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。 符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。 准备 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次） 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 public static final int value = 123; 解析 将常量池的符号引用替换为直接引用的过程。 初始化 初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 () 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 () 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” } static int i = 1; } 与类的构造函数（或者说实例构造器 ()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 () 方法运行之前，父类的 () 方法已经执行结束。因此虚拟机中第一个执行 () 方法的类肯定为 java.lang.Object。 由于父类的 () 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码： static class Parent { public static int A = 1; static { A = 2; } } static class Sub extends Parent { public static int B = A; } public static void main(String[] args) { System.out.println(Sub.B); // 输出结果是父类中的静态变量 A 的值，也就是 2。 } () 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 () 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 () 方法。但接口与类不同的是，执行接口的 () 方法不需要先执行父接口的 () 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 () 方法。 虚拟机会保证一个类的 () 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 四、类加载器 作用：运行时加载类 三个机制：委托性、可见性和单一性 委托性：双亲委派模型 可见性：子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类 单一性：仅加载一个类一次，由委托机制确保子类加载器不会再加载父类加载器加载过的类 分类： 从JVM角度： 启动类加载器，由C++实现，是虚拟机自身的一部分 其他类加载器，由Java实现，独立与虚拟机外部，继承自java.lang.ClassLoader 从开发人员角度： 启动类加载器（Bootstrap ClassLoader） ：此类加载器负责将存放在 \\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 /lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型： 双亲委派模型指的是类加载器之间的层次关系，要求除了顶层的启动类加载器外，其余的加载器都应有自己的父类加载器，这里的父子关系是使用组合关系。 工作过程：当一个类加载器收到加载类的请求，首先会将请求委派给父类加载器完成，最终传送到顶层的启动类加载器，只有当父加载器反馈无法完成这个加载请求时，子加载器才会尝试自己加载。 优点：提高安全性，使Java类随着类加载器具备带有优先级的层次关系。在该机制下，用户自定义的类加载器不可能加载本应由父加载器加载的类。 如何自定义类加载器： 继承ClassLoader类，重写findClass()方法 如何打破双亲委派机制： 继承ClassLoader类，重写findClass()、loadClass()方法 13. 触发minor GC、full GC的条件 minor GC： eden区满 full GC： System.gc()方法的调用，会建议full gc 老年代空间不足 统计得到的minor gc 晋升到老年代的平均大小大于老年代的剩余空间 CMS GC时出现promotion failed和concurrent mode failed 永生区空间不足 14. PermGen（永久代）和 Metaspace（元空间） 永久代是方法区的一种实现，主要存储类的相关信息、静态变量、常量等 JDK1.7中，永久代中的部分数据（符号引用、字面量、静态变量）转移到heap或native heap中，但永久代仍存在。 JDK1.8中，不存在永久代，增加了元空间 元空间与永久代类似，都是对JVM规范中方法区的实现。 区别：元空间不在虚拟机中，使用本地内存。默认情况下，元空间的大小受本地内存限制，但可以通过以下参数指定元空间的大小： -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 转换的原因： 字符串存在永久代，容易出现性能问题和内存溢出 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大容易导致老年代溢出。 永久代会为GC带来不必要的复杂度，并且回收效率偏低 "},"src/面试真题/SpringMVC.html":{"url":"src/面试真题/SpringMVC.html","title":"SpringMVC","keywords":"","body":"1. SpringMVC的工作流程 （1）用户发送请求到DispatcherServlet （2）DispatcherServlet收到请求后调用HandlerMapping （3）HandlerMapping根据请求的URL找到具体的处理器，生成处理器对象及处理器拦截器，返回给DispatcherServlet （4）DispatcherServlet调用HandlerAdapter （5）通过HandlerAdapter调用处理器 （6）处理器执行完后返回ModelAndView （7）HandlerAdapter将ModelAndView返回给DispatcherServlet （8）DispatcherServlet将ModelAndView传给ViewReslover （9）ViewReslover解析后返回具体View给DispatcherServlet （10）DispatcherServlet使用Model对View进行视图渲染（模型数据填充到视图中） （11）DispatcherServlet响应用户 2. SpringMVC 缺点 重量级 配置繁琐 "},"src/面试真题/数据库.html":{"url":"src/面试真题/数据库.html","title":"数据库","keywords":"","body":"1. 索引的失效情况 （1）条件中有or，有列不带索引 （2）对于多列索引，不是使用的第一部分 （3）like查询以%开头 （4）列是字符串，数据没用引号括起来 （5）mysql估计全表扫描比索引快 参考 2. 索引的实现原理 索引是数据库中一种排序数据结构，通常使用B树及其变种B+树，能有效的利用系统对磁盘的块读取特性，一个节点的大小为一页（4K），每个节点只需要一次IO读取。在读取相同磁盘块的同时，提高索引命中效率，达到减少磁盘IO的读取次数 3. 索引为什么不使用红黑树 虽然红黑树能达到高效的查询效率，但其基本是在内存中才会使用的数据结构。 在数据库中，数据存放在磁盘上，由于操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇，这使得磁盘读写有一个最少内容的限制，也就是当需要簇上的一字节内容，我们需要把整个簇的内容都读完。 试想红黑树中，一个父节点只有两个子节点，不能填满一个簇上的所有内容。一次IO操作获得的簇上只有两个子节点的信息。 再看看B+树，由于B+树节点的分支比二叉树更多，所以相同数量的内容，B+树的深度更浅，也表示磁盘IO操作次数更少。数据库设计的时候B+树具有多少分支是按照磁盘一个簇能存放多少节点设计的。 4. 为什么B+树比B树更适合数据库索引？ B+树的磁盘读写次数更少。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 B+树只需要去遍历叶子节点就可以实现整棵树的遍历 ，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 5. 聚簇索引与非聚簇索引 聚簇索引的逻辑顺序是数据在磁盘上的物理存储顺序 非聚簇索引的逻辑顺序与数据在磁盘上的物理存储顺序无关。 6. 如何分库分表 原理： 通过hash算法或工具将一张数据表垂直或水平地进行物理切分。 使用场景： 单表记录过大，达百万级或千万级； 解决表锁的问题，提高效率 分表方式： 水平分表：降低查询时读的数据和索引的页数，降低了索引的层数，提高查询效率 使用场景： 表中数据本身具有独立性，如不同地区数据或不同时期数据，某些数据常用，某些数据不常用 把数据放多个介质上 缺点： 给应用增加复杂度，查询时需要多个表名，查询所有数据需要UNION操作 查询时需要增加读一个索引层的磁盘次数 垂直分表：把主键和一部分列放一个表，接着把主键和另一部分列放一个表。 适用场景： 某些列常用，一些列不常用 缺点： 管理冗余列，查询所有数据需要join操作 7. 分区 对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。 创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有需要的数据的分区，这样只需要查询数据所在分区即可。 分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性的删除整个分区的数据也很方便。 适用场景 1、表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据。 2、分区表的数据更易维护，可以对独立的分区进行独立的操作。 3、分区表的数据可以分布在不同的机器上，从而高效适用资源。 4、可以使用分区表来避免某些特殊的瓶颈 5、可以备份和恢复独立的分区 8. 事务隔离级别 由弱到强： 未提交读（Read Uncommited）：（脏读、不可重复读、幻读） 已提交读（Read Committed）：只能读到已提交的数据，Oracle等数据库默认级别（不可重复读、幻读） 可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别（幻读） 串行读（Serializable）：完全串行化的读，每次读都要获取表级共享锁，读写相互阻塞 事务并行产生问题： 脏读：当A事务在对数据进行修改，并且还没提交，事务B也能访问、使用该数据 不可重复读：在A事务内，多次读同一数据，由于B事务在两次读数据之间，对数据进行修改，导致两次读到的数据不同（重点在于修改，两次读取的值不同） 幻读：A事务对表中所有数据进行修改，事务B修改数据，如插入了一条记录，A事务执行完后，表中存在未修改的数据（重点在于新增或删除，两次读取的记录数不同） 9. MVCC MVCC（Multi-Version Concurrent Control），多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的快照，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这里的版本可以是时间戳或全局递增的事务ID。在同一个时间点，不同的事务看到的数据版本不同。 mysql 的 InnoDB 引擎如何实现MVCC？ 为每一行添加两个隐藏字段，记录该行数据何时被创建、何时被删除，具体存储的是事务的版本号，随着新事务开启其版本号会增加。在可重复读Repeated Read级别下： SELECT：读取创建版本号 当前事务版本号 INSERT：保存当前事务版本号为行的创建版本号 DELETE：保存当前事务版本号为行的删除版本号 UPDATE：插入一条新纪录，保存当前事务版本号为行的创建版本号，同时保存当前事务版本号为原来行的删除版本号 Mysql的RR级别能避免幻读，如何解决？ Gap锁，在锁住行的两边区间加gap锁，防止别的事务新增。 行锁和Gap锁结合形成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。 10. 范式 1NF ：字段不可再分，原子性 2NF ：满足1NF。一个表只能说明一个事物，非主键属性必须完全依赖于主键属性。 3NF ：满足2NF。每列都与主键有关系，不存在传递依赖。任何非主属性不依赖于其他非主属性。 不符合1NF： 表：字段1，字段2（字段2.1，字段2.2），字段3 不符合2NF： 表：学号，姓名，年龄，课程名称，成绩，学分 不符合3NF： 学号，姓名，年龄，所在学院，学院地点，学院联系电话 传递依赖：学号->所在学院->（学院地点，学院联系电话） 11. truncate、delete、drop 相同点： truncate和不带where子句的delete、以及drop都会删除表内的数据。 drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。 不同点： truncate 和 delete 删除数据，不删除表的结构(定义) drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。 delete 语句是数据库操作语言(dml)，事务提交之后才生效，可回滚，触发 trigger。 truncate、drop 是数据库定义语言(ddl)，操作立即生效，不能回滚，不触发 trigger delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动 drop 语句将表所占用的空间全部释放。 truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。 速度，一般来说: drop> truncate > delete 安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及 使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大. 想删除表,当然用 drop 想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。 如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。 TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 TRUNCATE TABLE 不能用于参与了索引视图的表。 12. 事务的四大特性 ACID：原子性、一致性、隔离性、持久性 13. 存储引擎 MyISAM、InnoDB、Memory MyISAM与InnoDB的区别： 事务 MyISAM不支持事务 InnoDB支持事务 外键 MyISAM不支持外键 InnoDB支持外键 锁 MyISAM只支持表级锁 InnoDB支持行级锁、表级锁，默认行级锁 全文索引 MyISAM支持全文索引 InnoDB不支持全文索引（5.6以后开始支持） 表主键 MyISAM 允许表没有主键 InnoDB 若未设定主键，会自动生成一个6字节的主键（用户不可见） 表的具体行数 MyISAM 保存表的行数 InnoDB 不保存表的行数，需要扫描整个表计算行数 MyISAM和InnoDB的应用场景： MyISAM：适用查询性能要求较高、非事务表。查询性能优于InnoDB的原因是，MyISAM的索引和数据是分开的，可以更好的利用内存 InnoDB：用于事务处理程序。执行大量Insert和Update操作， Memory存储引擎 使用存储在内存中的数据来创建表，数据全部放在内存中。 默认使用Hash索引，速度比B型树索引快 若内存出现异常会影响数据，如果重启或关机，数据全部消失。 14. 优化查询SQL 检查索引 在SQL语句的 where 和 join 部分中用到的所有字段，都应该加上索引 限制工作数据集的大小 检查是否可以应用 where 进行 删除不需要的字段、表 删除 where 和 join 子句的计算字段 15. 查询语句不同元素的执行先后顺序（where、join、limit、group by、having） 书写顺序： select -- from -- where -- group by -- having -- order by 执行顺序： from：从哪个表检索数据 where ：过滤表中的条件 group by：对过滤的数据分组 having：对分组后的数据进行过滤 select：查看结果集中哪个列，或列的计算结果 order by：按照什么顺序来查看返回数据 from、where 条件的解析顺序 from 的表关联是 自右向左 （数据量小的表放最右边，用小表匹配大表） where 的条件 是 自左向右 （排除越大数据的条件放左边） 16. 临时表 17. 索引类型 从数据结构角度 1、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理 2、hash索引： a 仅仅能满足\"=\",\"IN\"和\"\"查询，不能使用范围查询 b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引 c 只有Memory存储引擎显示支持hash索引 3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了） 4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引） 从物理存储角度 1、聚集索引（clustered index） 2、非聚集索引（non-clustered index） 从逻辑角度 1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值 2、普通索引或者单列索引 3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合 4、唯一索引或者非唯一索引 5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建 CREATE TABLE table_name[col_name data type] [unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc] 1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引； 2、index和key为同义词，两者作用相同，用来指定创建索引 3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择； 4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值； 5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； 6、asc或desc指定升序或降序的索引值存储 18. 乐观锁、悲观锁 悲观锁 先获取锁、再进行业务操作 一锁二查三更新 需要数据库本身提供支持。select ... for update 实现悲观锁。获取的行锁在当前事务结束时自动释放，必须在事务中使用。 MySQL中 select ... for update 执行中所有扫描过的行都会上锁，因此用悲观锁务必要确定使用索引，不是全表扫描 乐观锁 乐观并发控制。不加锁，进行业务操作，在提交数据更新前，检查在该事务读取数据后，有没有其他事务修改该数据。若有，则当前提交的事务会回滚。 不需要数据库提供支持。在需要锁的数据上增加一个版本号，或时间戳 应用场景 乐观锁：需要非常高的响应速度，成功就执行，不成功则失败 悲观锁：冲突频率非常高，重试代价大 19. 非关系型数据库和关系型数据库区别 非关系型数据库： 性能高，基于键值对，不需要经过SQL层解析 可扩展性，基于键值对，数据之间没有耦合性 关系型数据库： 复杂查询，用SQL语句方便在一个表或多个表之间做非常复杂的查询 事务支持 20. 主从复制 三种方式： 同步复制：master的变化，必须等待 slave-1，slave-2，...，slave-n完成才能返回。不可取。比如，在WEN前端页面上，用户增加条记录，需要等待很长时间。 异步复制：master只需完成自己的数据库操作，不用关心slaves是否收到二进制日志。MySQL的默认设置 半同步复制：master只保证slaves中的一个操作成功，就返回，其他slaves不管 问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？ 假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作 问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？ 实现数据备份，读写分离 问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库? "},"src/面试真题/计算机网络.html":{"url":"src/面试真题/计算机网络.html","title":"计算机网络","keywords":"","body":"1. cookie与session session session，是服务器端技术，会为每个客户端创建一个其独享的session对象。可存放文件、内存或数据库，以键值对形式存储 session 的客户端实现形式： 使用 Cookie 保存 URL 重写 表单隐藏域 若 cookie 被禁用，可使用后两种把sessionID传给服务器 session 什么时候被创建？ servlet 中手动调用 HttpSession session = request.getSession(); HttpSession session = request.getSession(true); jsp 中没有写 （默认 session = \"true\"） session 什么时候被删除？ 程序调用 HttpSession.invalidate() 距离上次收到客户端发送的session id 时间间隔超过了 session 的最大有效时间 服务器进程被停止 cookie cookie，是客户端技术，由服务器产生存储在客户端，可以用于辨别用户身份、进行session跟踪。 分类： 存储在硬盘上的永久性cookie 存储在内存上的临时性cookie 有效性： maxAge 决定 cookie 有效期， 单位秒 正数：浏览器将 cookie 持久化 Cookie cookie = new Cookie(\"username\", \"chaycao\"); cookie.setMaxAge(Integer.MAX_VALUE); response.addCookie(cookie); 负数：临时性 cookie （浏览器默认maxAge值 -1） 0：删除该 cookie Cookie cookie = new Cookie(\"username\", \"chaycao\"); cookie.setMaxAge(0); // 删除该cookie response.addCookie(cookie); cookie 的组成部分 标准格式：Set-Cookie: NAME=VALUE; Expires=DATE; Path=PATH; Domain=DOMAIN_NAME; SECURE; 例子：Set-Cookie: JSESSIONID=fjdsofjaioufy; Expires=Thu, 05-Jun-2018 05:02:50; Path=/web; expires : 有效时间，过了则自动删除，若不设置，则为临时性cookie Path，Domain：一起构成 cookie 的作用范围；Domain可以使多个web服务器共享cookie，path指定与cookie关联一起的网页 cookie 和 session 原理解析： 客户端第一次发请求给服务器，服务器产生一个唯一的 sessionID，并返回给客户端（通过cookie，没有setMaxAge()） 客户端将cookie保存在内存中，再发送请求时，会在 request 中携带 cookie 服务器根据 cookie 中的 sessionID，可找到对应的session cookie与 session区别 存放位置。cookie数据存放在客户端上，session数据存放在服务器上 安全性。cookie由于存放在客户端，所以安全性低，可通过分析存放本地cookie进行cookie欺骗 有效期。cookie可以在浏览器上保存较长时间。session只需关闭浏览器就会失效。 对服务器的压力。cookie保管在客户端，不占用服务器资源。大量并发访问用户，会产生大量session，耗费大量内存。 跨域支持。cookie支持跨域，session不支持，仅在他所在域名内有效。 容量和个数。单个cookie的容量不超过4KB，很多浏览器限制单个站点最多20个cookie。session没有容量个数限制。 建议：登录信息等重要信息存放 session 中，其他信息可放在 cookie 中。 session 与 cache 区别 session 是单用户的会话状态 cache 是服务器端的缓存，所有用户都可访问、共享 2. 输入网址到浏览器显示页面的过程 浏览器输入网址 域名解析，查找域名的IP 浏览器缓存 系统缓存 路由器缓存 ISP DNS缓存 ISP DNS服务器递归搜索 与IP地址对应的服务器建立TCP连接，三次握手 发送HTTP请求 获得服务器响应，显示页面 用到协议：IP、ARP、OSPF、TCP 3. 五层网络模型 应用层 传输层 网络层 链路层 物理层 4. HTTP的请求方法 HTTP1.0有3种： GET：从服务器获得一份文档 POST：向服务器发送需要处理的数据 HEAD：从服务器获得响应报文的首部 HTTP1.1新增5种： OPTIONS：获取服务器支持的HTTP请求方法；检查服务器性能 PUT：将请求的主体部分存储在服务器上 DELETE：从服务器上删除一份文件 TRACE：对可能经过代理服务器传送到服务器上的报文进行追踪 CONNECT：1.1中预留给能将连接改为管道方式的代理服务器 GET 与 POST的区别： GET POST 用途 获取资源 发送数据 数据 通过URL请求后缀，可见 通过POST机制，将字段和对应值封装在请求实体中，不可见 数据量 小，受URL长度限制，但效率高 可传输大量数据 安全性 不安全，URL可见 安全 支持字符 支持ASCLL 支持标准字符 5. HTTP的无状态，如何保持状态 HTTP的无状态是指协议对于事务处理没有记忆能力。 优点：节省服务器资源。服务器不用为每个客户端连接分配内存来记忆大量状态，失去连接时清理内存。 缺点：传送的数据量可能增大。若需要之前的信息，客户端需要重传。 保持状态可采用会话跟踪技术。把状态保存在服务器中，发送给客户端标志符，客户端下次提交再把标志符发送给服务器，则可以定位存储在服务器上的状态信息。 4种会话跟踪技术： session cookie url 重写 隐藏表单域 6. HTTP的短连接和长连接 HTTP/1.0 中默认使用短连接。浏览器和服务器每进行一次HTTP操作，就建立一次连接。 需要在 request 中增加“Connection: keep-alive” header 才能建立长连接 HTTP1.0 keepAlive的数据交互流程： 客户端发出request，包含header “Connection: keep-alive” 服务器收到该request后，发出包含header “Connection: keep-alive”的response。同时不会关闭已建立的 TCP 连接 客户端收到response后，不关闭 TCP连接，并用该连接再发生 request。 HTTP/1.1 中默认使用长连接。请求和响应都会加入 \"Connection: keep-alive\" 关闭长连接： keepAlive有一个保持时间，可以在服务器软件中设置。 请求或响应中 Connection: closed HTTP协议的长连接和短连接，实质是TCP协议的长连接和短连接 HTTP长连接的优点： 减少TCP连接开启和关闭，节约CPU时间和内存 减少TCP连接开启和关闭引起的包数量，降低网络阻塞 HTTP长连接的缺点： 服务器维护长连接增加开销 HTTP短连接的优点： 节省服务器资源 HTTP短连接的缺点： 如果客户端请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 7.HTTP 1.0、1.1、2.0区别 1.0 与 1.1的区别： 长连接 HTTP 1.0 需要使用 keep-alive 参数来告知服务器端建立长连接。HTTP 1.1 默认支持长连接 状态码 100 Continue HTTP 1.1 支持只发送 header 信息（无 body 信息），当接收到100时，才开始把 body 发送，当收到 401 时，就不发送 body HOST 域 web server上的多个虚拟站点可以共享同一个 ip 和端口。HTTP 1.0 不支持，HTTP 1.1 支持，Request消息头多了一个Host域 分块传输数据 HTTP 1.0 通过Content-Length字段指定实体长度，对于动态生成的响应，需要缓存整个响应 HTTP 1.1 引入分块传输，将消息实体分割为任意大小的组块，单独发送 1.1 与 2.0的区别： 多路复用 2.0 同一个连接并发处理多个请求 1.1 则是多建立几个 TCP 连接，来支持并发请求，创建 TCP 连接有开销 数据压缩 1.1 不支持 header 数据的压缩 2.0 使用 HPACK 算法对 header 数据压缩，数据体积小了，在网络上传输速度更快 服务器推送 对支持 HTTP 2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，非常适合加载静态资源 8. HTTP 与 HTTPS HTTP存在的安全问题： 通信使用明文，不加密，内容可能被窃听 不验证通信对方身份，可能遭到伪装 无法验证报文完整性，可能被篡改 HTTPS 在 HTTP 加上 加密处理 + 认证 + 完整性保护 HTTPS 用到的技术： 对称加密算法：加密传输数据 非对称加密算法：加密生成的密码 数字证书：验证身份 散列算法：验证数据完整性 HTTP 与 HTTPS 区别 HTTPS更安全 HTTPS需要申请证书 端口不同：HTTP 80，HTTPS 443 层次不同：HTTP在TCP之上，HTTPS在SSL/TLS之上 9. HTTP 状态码 1XX ：指示信息——请求已接收，需要请求者继续执行操作 2XX：成功——操作被成功接收并处理 3XX：重定向——需要进一步操作以完成请求 4XX：客户端错误，请求包含语法错误或无法完成请求 5XX：服务器错误，服务器在处理请求的过程中发生了错误 200 OK ：请求被正常处理 202 Accepted ：已接收请求，但处理尚未完成 204 No Content：请求被受理但没有资源可以返回 206 Partial Content：客户端进行范围请求，响应报文由 Content-Range 指定实体内容的范围。实现断点续传 301 Moved Permanently：永久重定向，请求的网页已永久移到新位置 302 Moved Temporatily：临时重定向，请求网页临时移到新位置 304 Not Modified：未修改。所请求资源未修改，服务器不返回资源，客户端会从缓存中访问资源。 400 Bad Request：请求报文语法有误，服务器无法识别 401 Unauthorized：请求需要认证 403 Forbidden：服务器拒绝请求 404 Not Found：服务器无法找到对应资源 500 Internal Server Error：服务器内部错误 503 Service Unavailable：服务器正忙 10. HTTP的特点 支持CS通信模式 简单方便快捷：协议简单，通信速度快 灵活：运行传输任意类型任意格式的数据对象，由Content-Type标记 无连接 无状态 11. ARP（地址解析协议） 解决同一局域网内，主机或路由器的 IP 地址和 MAC 地址的映射问题。 如果源主机和目的主机在同一个局域网内（目标IP和本机IP与子网掩码相与结果相同，则在同一个子网），可通过ARP找到目的主机的MAC地址；若不在同一局域网内，用ARP找到本网络的一个路由器的MAC地址，剩下工作由路由器完成。 ARP 协议的具体内容： 每个主机有ARP高速缓存，存储本局域网内IP地址与MAC地址之间的映射 当源主机发送数据时，首先检查ARP高速缓存中是否有对应IP的MAC地址，若有，则直接发送数据，若没有，向本网段的所有主机发送ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址） 当本网段的所有主机收到ARP请求分组时，检查目的主机IP地址是否是自己的IP地址，若不是，则忽略；若是，则将源主机IP地址和MAC地址写入ARP高速缓存中，将自己的MAC地址写入ARP响应包中。 源主机收到ARP响应分组后，将目的主机IP和MAC地址写入ARP高速缓存。若一直没收到ARP响应分组，则ARP查询失败 12. 路由器与交换机的区别 交换机工作在数据链路层；路由器工作在网络层 交换机转发数据帧；路由器转发IP分组 交换机隔离冲突域，不隔离广播域；路由器隔离冲突域，隔离广播域 13. TCP如何保证可靠传输 传递数据前，三次握手建立连接 将数据截断为合理的长度 超时重发 对于收到的请求，给出确认响应 效验出包有错，丢弃报文段，不给出响应，TCP发送数据段，超时时会重发数据 对失序数据进行重新排序，再交给应用层 对于重复数据，能够丢弃重复数据 TCP提供流量控制，防止较快主机致使较慢主机的缓冲区溢出 TCP提供拥塞控制，当网络拥塞时，减少数据发送 14. TCP 的三次握手和四次挥手 15. TCP的流量控制 流量控制：让发送方的发生速率不要太快，让接收方来得及接收 原理：滑动窗口机制。运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 16. TCP的拥塞控制 拥塞控制是为了降低网络的拥塞程度 4种算法：慢开始、拥塞避免、快重传、快恢复 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量（拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口） 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ... 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。 快重传与快恢复 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 17. TCP与UDP 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 区别： 基于连接 vs 无连接 TCP 面向连接；UDP 无连接 可靠性 TCP 提供可靠交付，若有消息丢失，则重发；UDP 不可靠 有序性 TCP 会将消息进行排序；UDP 不提供有序性的保证 速度 TCP 速度慢；UDP 速度快 重量级 vs 轻量级 TCP 重量级，报头最少20字节（序列号、ACK号、数据偏移量、保留、控制位、窗口、紧急指针、可选项、填充项、校验位、源端口、目的端口） UDP 轻量级，报头固定8字节（长度、源端口号、目的端口、校验和） 流量控制或拥塞控制 TCP 有流量控制和拥塞控制；UDP没有 TCP 面向字节流，UCP 面向报文 TCP 只能单播，UDP 可以广播和组播 应用场景： TCP：效率要求相对低，准确性要求相对高的场景。如文件传输、邮件传输、远程登录 UDP：效率要求相对高，准确性要求相对低的场景。如视频聊天、网络电话、广播通信 TCP安全，但还有很多用UDP？ 无需建立连接，减少延迟 无需维护连接状态 头部开销小 应用层能更好控制发送数据和发送时间，网络中的拥塞不会影响主机的发送频率 UDP为何快？ 无需建立连接 对于收到的数据，不用给出确认 没有超时重传 没有流量控制和拥塞控制 18. RESTFul REST - representational state transfer，表现层状态转移 用URL定位资源，用HTTP动词（GET、POST、DELETE、DELETE）描述操作 优点 轻量，直接基于http，不在需要任何别的诸如消息协议。get/post/put/delete为CRUD操作 面向资源，一目了然，具有自解释性。 数据描述简单，一般以xml，json做数据交换。 缺点 导致设计uri变得复杂了。尤其是复杂的关系，操作，资源集合 。 HTTP动词太少，只有CRUD，复杂操作不适用，如部分更新 批量的删除、修改、新增（将多个资源看做单个资源） "},"src/面试真题/算法.html":{"url":"src/面试真题/算法.html","title":"算法","keywords":"","body":"1. 乱序算法 public static void shuffle(int[] array) { for (int i = array.length-1; i > 0; i--) { Random random = new Random(); int x = random.nextInt(i); swap(array, x, i); } } public static void swap(int[] array, int a, int b) { int temp = array[a]; array[a] = array[b]; array[b] = temp; } 2. 加密算法 常用的对称加密算法有：DES、3DES、RC2、RC4、AES 常用的非对称加密算法有：RSA、DSA、ECC 使用单向散列函数的加密算法：MD5、SHA 3. 排序算法 简介 插入排序：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 希尔排序：对直接插入排序的一种优化，实质就是把直接插入排序改为了分组插入排序。其基本思想就是将整个待排序元素序列按gap（步长）分割为N个组，对每个组进行直接插入排序，然后在减小gap（步长）再进行直接插入排序，直到gap达到最小时，即数组基本达到有序时，再对数组进行直接插入排序，此时直接插入排序就可以达到最高效率。 选择排序：每次通过从无序的数组中选择出一个最小的（要求升序排列）数把他放到数组的最前面。再依次找次小的数字放到数组无序区的最前。直到数组为有序。 堆排序：从基本实现原理来说也是一种选择排序，它同样是确定了位置选择符合位置的元素，但是堆排序是更加优化的选择排序的版本，它利用了堆的特性。父结点的值大于子结点，且满足完全二叉树，大大提高了选择排序的效率。 冒泡排序： 相近的两个数字作比较，小的放到前面，大的放后面，按照这个规则从头向后比较，最大的数就被换到了数组尾。 快速排序：是一种在实际应用中经常用到的排序算法，它的应用场景是大规模的数据排序，并且实际性能要好于归并排序。从数组中选取一个元素，把所有大于这个元素的数都放到它的后面，所有小于这个元素的数都放到它的前面，然后这个元素就把原数组切分成了两个部分，再分别对这个两个部分进行同样的操作，直到数组不能再切分的时候，此时数组为有序。 归并排序：将两个或两个以上的有序表组合成一个新的有序表，归并排序和快排一样也采用的是分治的思想，它的基本原理是通过对若干个有序结点序列的合并为一个有序序列来实现排序的。 基数排序：通过分配的方法把元素从小到大分配，以到达排序的作用。 比较 应用场景 (1) 若n较小(如n≤50)，可采用直接插入或直接选择排序。 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。 (2) 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜； (3) 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。 这两种排序都是不稳定的。 若要求排序稳定，则可选用归并排序。但前面介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子序列，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。 4. 动态规划和分治法 分治法，动态规划法，这两者之间有类似之处，比如都需要将问题划分为一个个子问题，然后通过解决这些子问题来解决最终问题。但其实这两者之间的区别还是蛮大的。 1.分治法 ​ 分治法（divide-and-conquer）：将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。 分治模式在每一层递归上都有三个步骤： 分解（Divide）：将原问题分解成一系列子问题； 解决（conquer）：递归地解各个子问题。若子问题足够小，则直接求解； 合并（Combine）：将子问题的结果合并成原问题的解。 合并排序（merge sort）是一个典型分治法的例子。其对应的直观的操作如下： 分解：将n个元素分成各含n/2个元素的子序列； 解决：用合并排序法对两个子序列递归地排序； 合并：合并两个已排序的子序列以得到排序结果。 2. 动态规划法 动态规划算法的设计可以分为如下4个步骤： 描述最优解的结构 递归定义最优解的值 按自底向上的方式计算最优解的值 由计算出的结果构造一个最优解 ​ 分治法是指将问题划分成一些独立地子问题，递归地求解各子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题独立且重叠的情况，也就是各子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。 适合采用动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题。 最优子结构：如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。 ​ 重叠子问题：适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要很小，也就是用来求解原问题的递归算法课反复地解同样的子问题，而不是总在产生新的子问题。对两个子问题来说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，则它们是重叠的。 ​ “分治法：各子问题独立 动态规划：各子问题重叠” ​ 算法导论： 动态规划要求其子问题既要独立又要重叠，这看上去似乎有些奇怪。虽然这两点要求听起来可能矛盾的，但它们描述了两种不同的概念，而不是同一个问题的两个方面。如果同一个问题的两个子问题不共享资源，则它们就是独立的。对两个子问题俩说，如果它们确实是相同的子问题，只是作为不同问题的子问题出现的话，是重叠的，则它们是重叠的。 "},"src/面试真题/大数据.html":{"url":"src/面试真题/大数据.html","title":"大数据","keywords":"","body":"1. 两个大文件找出共同记录 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url? 采用分治法的思想 第一步，遍历文件a，设计一个hash函数，将url划分成多个小文件，例如划分成1000个，则对每个url取Hash(url)%1000，得到1000个小文件 第二步，遍历文件b，用与a同样的方式，将url划分成小文件，这里使用相同的hash函数，也同样得到1000个小文件。 现在问题转换成了，找出1000对小文件中每一对相同的url读取小文件a，建立哈希表，再读取文件b，对于每个url，若在hash表中搜索到，则说明两者共有，存起来 https://blog.csdn.net/v_july_v/article/details/7382693 https://blog.csdn.net/v_JULY_v/article/details/6279498 "},"src/Python/环境/":{"url":"src/Python/环境/","title":"环境","keywords":"","body":"环境 "},"src/Python/环境/包导出.html":{"url":"src/Python/环境/包导出.html","title":"包导出","keywords":"","body":"包导出 pip导出 pip freeze > requirements.txt pip wheel -r requirements.txt pip install --use-wheel --no-index --find-links=wheelhouse -r requirements.txt "},"src/Web/XML.html":{"url":"src/Web/XML.html","title":"XML","keywords":"","body":"XML XML的生成解析方法 DOM DOM（Document Object MOdel）是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。 优点： 允许应用程序对数据和结构做出更改。 访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。 编程容易 缺点： 通常需要加载整个XML文档来构造层次结构，消耗资源大。 使用场景： XML文档需要频繁改变 SAX SAX采用事件模型，在解析XML文档时可以促发一系列事件，当发现给定 tag 时，可以激活一个回调函数，告诉该方法 tag 已找到。SAX对内存的要求通常会比较低，因为它让开发人员自己来决定所要处理的tag.特别是当开发人员只需要处理文档中所包含的部分数据时，SAX这种扩展能力得到了更好的体现。但用SAX解析器的时候编码工作会比较困难，而且很难同时访问同一个文档中的多处不同数据。 优点： 不需要等待所有数据都被处理，分析就能立即开始。 只在读取数据时检查数据，不需要保存在内存中。 可以在某个条件得到满足时停止解析，不必解析整个文档。 效率和性能较高，能解析大于系统内存的文档。 缺点： 需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂。 单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。 JDOM JDOM（Java-based Document Object Model）与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。 JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。 优点： 使用具体类而不是接口，简化了DOM的API。 大量使用了Java集合类，方便了Java开发人员。 缺点： 没有较好的灵活性。 性能较差。 DOM4J DOM4J（Document Object Model for Java）合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项，它通过DOM4J API和标准DOM接口具有并行访问功能。 优点： 大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法。 支持XPath。 有很好的性能。 缺点： 大量使用了接口，API较为复杂。 比较 DOM4J 性能最好，若不考虑可移植性，则推荐采用 JDOM、DOM 在性能上表现不佳，但可移植 SAX 性能表现较好 如果XML文档较大且不考虑移植性问题建议采用DOM4J； 如果XML文档较小则建议采用JDOM； 如果需要及时处理而不需要保存数据则考虑SAX。 "},"src/Linux/常用命令.html":{"url":"src/Linux/常用命令.html","title":"常用命令","keywords":"","body":"常用命令 查看CPU信息 CPU的信息在启动过程中被装载到虚拟目录/proc下的cpuinfo中 cat /proc/cpuinfo 重要指标： process：逻辑处理器的ID physical id：物理封装的处理器ID siblings：位于相同物理封装的处理器中的逻辑处理器的忽略 cpu id：内核的ID cpu cores：位于相同物理封装的处理器中的内核数量 在该服务器上 physical id 有2个 —— 有两个物理CPU cpu cores 为4 —— 1个物理CPU里有4个内核 core id 有8个 —— 总共有8个内核 (所有物理CPU内核总数） silbings 为8 —— 1个物理CPU里有8个逻辑CPU processor 有16个——总共有16个逻辑CPU 总核数 = 物理CPU个数 * 每颗物理CPU的核数 总逻辑CPU数 = 物理CPU个数 每颗物理CPU的核数 超线程数 # 查看物理CPU个数 cat /proc/cpuinfo| grep 'physical id'| sort| uniq| wc -l # 查看每个物理CPU的核数 cat /proc/cpuinfo| grep 'cpu cores'| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep 'processor'| wc -l 查看系统负载 Linux 的负载高，主要是由于下面三部分构成： CPU使用 内存使用 IO消耗 1.uptime 系统平均负载：特定时间间隔内运行队列中的平均进程数 若每个CPU内核的当前活动进程数不大于3，性能良好 若大于5，则系统超负荷运转 2.w 3.top Linux下的任务管理器，能够实时显示系统中各个进程的资源占用状况，查看命令详细) 4.free 相比top，提供更简洁的系统内存使用情况，查看命令详细 5.vmstat 展现给定时间间隔的服务器状态值，如CPU使用率、内存使用、虚拟内存交换情况、IO读写情况，查看命令详细 查看网卡流量 sar "},"src/Linux/常用命令/文件及目录管理.html":{"url":"src/Linux/常用命令/文件及目录管理.html","title":"文件及目录管理","keywords":"","body":"文件及目录管理 创建和删除 创建：mkdir 删除：rm 删除非空目录：rm - rf 目录 删除日志：rm \\*log（等价：find ./ -name \"\\*log\" -exec rm {};） 移动：mv 复制：cp （复制目录：cp -r source_dir dest_dir） 查看当前目录下文件个数：find ./ | wc -l 目录切换 切到文件\\目录位置：cd 目录 切到上一个目录：cd .. 切到home目录：cd ~ 显示当前路径：pwd 列出目录项 显示当前目录下的文件：ls 按时间排序，以列表方式显示目录项：ls -lrt 查找目录及文件 按部分文件名搜索文件或目录：find ./ -name \"core*\" 查看文件内容 查看文件：cat、vi、head、tail、more 查找文件内容 查找文件内容：egrep 查找字符串 文件或目录 文件与目录权限修改 改变文件的拥有者：chown 改变文件读、写、执行等属性：chmod 递归子目录修改：chown -R tuxapp source/ 增加脚本可执行权限：chmod a+x myscript 文件增加别名 创造硬链接：ln 源目录 目标文件 创造软链接：ln -s 源目录 目标文件 管道和重定向 批处理命令连接执行：| 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行: && 前面失败，则后一条执行: || "},"src/Linux/常用命令/磁盘管理.html":{"url":"src/Linux/常用命令/磁盘管理.html","title":"磁盘管理","keywords":"","body":"磁盘管理 查看磁盘空间 查看磁盘空间利用大小：df -h 查看当前目录所占空间：du -sh 查看当牧师所有子文件排序后的大小：du -sh 'ls' | sort "},"src/Linux/常用命令/进程管理.html":{"url":"src/Linux/常用命令/进程管理.html","title":"进程管理","keywords":"","body":"进程管理 查询进程 查询正在运行的进程信息：ps -ef 根据进程名查询进程：pgrep -l 进程名 显示进程信息，并实时更新：top 查看端口占用的进程状态：lsof -i:3306 查询用户user的进程所打开的文件：lsof -u user 查询init进程当前打开的文件：lsof -c init 查询指定进程ID打开的文件：lsof -p ID 查询指定目录下被进程开启的文件：lsof +d 目录 终止进程 杀死指定PID的进程：kill PID 杀死相关进程：kill -9 3434 进程监控 查询系统CPU、使用内存最多的进程：top，再输入P，进行排序 分析线程栈 输出进程内存的状态：pmap "},"src/Linux/常用命令/性能管理.html":{"url":"src/Linux/常用命令/性能管理.html","title":"性能管理","keywords":"","body":"性能管理 "},"src/Linux/":{"url":"src/Linux/","title":"命令详解","keywords":"","body":"命令详解 "},"src/Linux/命令详解/top.html":{"url":"src/Linux/命令详解/top.html","title":"top","keywords":"","body":"TOP 能够实时显示系统中各个进程的资源占用状况 统计信息区（前5行） 第一行，任务队列信息，同 uptime 命令的执行结果 第二行，Tasks，系统共有435个进程，其中2个在运行，433个在休眠，0个stoped，0个zombie（僵尸） 第三行，CPU状态 us —— 用户空间占用CPU的百分比 sy —— 内核空间占用CPU的百分比 ni —— 改变过优先级的进程占用CPU的百分比 id —— 空间CPU百分比 wa —— IO等待占用CPU的百分比 hi ——硬中断占用CPU的百分比 si —— 软中断占用CPU的百分比 第四行，内存状态 total —— 物理内存总量 userd —— 使用内存总量 free —— 空闲内存总量 buffers —— 缓存内存总量 第五行，swap交换分区信息 交换区总量 使用交换区总量 空闲交换区总量 缓存交换区总量 备注： 第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。 如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存 对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。 各进程（任务）的状态监控（第七行以下） PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） "},"src/Linux/命令详解/free.html":{"url":"src/Linux/命令详解/free.html","title":"free","keywords":"","body":"free 相比top，提供更简洁的系统内存使用情况 参数说明 Mem：表示物理内存统计 Total：表示物理内存总大小。 Used：表示总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。 Free：表示未被分配的内存。 Shared：共享内存，一般系统不会用到。 Buffers：系统分配但未被使用的buffers 数量。 Cached：系统分配但未被使用的cache 数量。 -/+ buffers/cached：表示物理内存的缓存统计 Used：实际使用的buffers 与cache 总量，也是实际使用的内存总量。 Free: 未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。 Swap：表示硬盘上交换分区的使用情况。只有mem被当前进程实际占用完,即没有了buffers和cache时，才会使用到swap。 实际可用内存大小： ​ Free（-/+ buffers/cache行）= Free(Mem)+buffers(Mem)+Cached(Mem); 已经分配的内存大小： ​ Used(Mem) = Used(-/+ buffers/cache)+ buffers(Mem) + Cached(Mem) 物理内存总大小 ​ total（Mem） = used(-/+ buffers/cache) + free(-/+ buffers/cache) ​ 1035108 = 471772 + 563336 buffer 与 cache 的区别 A buffer is something that has yet to be \"written\" to disk. A cache is something that has been \"read\" from the disk and stored for later use. cache Cache：高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。 由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。 Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。 buffer Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。 比较 在Free命令中显示的buffer和cache，它们都是占用内存： buffer : 作为buffer cache的内存，是块设备的读写缓冲区，更靠近存储设备，或者直接就是disk的缓冲区。 cache: 作为page cache的内存, 文件系统的cache，是memory的缓冲区 如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。 "},"src/Linux/命令详解/vmstat.html":{"url":"src/Linux/命令详解/vmstat.html","title":"vmstat","keywords":"","body":"vmstat 展现给定时间间隔的服务器状态值，如CPU使用率、内存使用、虚拟内存交换情况、IO读写情况 参数： 采用的时间间隔数，单位秒 采样的次数 r 表示正在跑的任务数，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。 b 表示阻塞的进程。 swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。 free 空闲的物理内存的大小。 buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存 cache cache直接用来记忆我们打开的文件,给文件做缓冲(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。) si 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。 so 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte。 bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 in 每秒CPU的中断次数，包括时间中断 cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。 us 用户进程执行时间百分比，值高，说明用户进程消耗的CPU时间多，若长期超过50%，该考虑优化程序算法或进行加速。 sy 内核系统进程执行时间百分比，如果太高，表示系统调用时间长，例如是IO操作频繁。 id 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。 wa 等待IO CPU时间，值高，说明IO等待严重，可能由于磁盘大量做随机访问造成，也有可能磁盘出现瓶颈（块操作）。 "},"src/MySQL/":{"url":"src/MySQL/","title":"锁","keywords":"","body":"锁 "},"src/MySQL/锁/悲观锁与乐观锁.html":{"url":"src/MySQL/锁/悲观锁与乐观锁.html","title":"悲观锁与乐观锁","keywords":"","body":"悲观锁与乐观锁 概念 乐观锁（乐观并发控制）和悲观锁（悲观并发控制）是并发控制主要采用的技术手段。 可认为是一种思想。针对不同的业务场景，应选用不同的并发控制。 不要将其与锁机制（行锁、表锁、排它锁、共享锁）混为一谈 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作（一开始的时候就上锁） 应用场景：数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 例子：Java synchronized属于悲观锁的一种实现 乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性，若其他事务有更新的话，正在提交的事务进行进行回滚。 应用场景：读多写少，可提高吞吐量 实现方式：（1）数据版本（version）；（2）时间戳（timestamp） 例子：Java中的atomic包，AtomicInteger通过CAS操作实现线程安全的自增 MySQL中使用 MySQL InnoDB中使用悲观锁 首先关闭MySQL数据库的自动提交属性，set autocommit=0; //0.开始事务 begin; //1.查询出商品信息 select status from t_goods where id=1 for update; //2.根据商品信息生成订单 insert into t_orders (id,goods_id) values (null,1); //3.修改商品status为2 update t_goods set status=2; //4.提交事务 commit; 在查询语句中，使用select ... for update的方式，通过开启排它锁的方式实现悲观锁。 但需要注意，InnoDB 默认行级锁，行级锁是基于索引的，如果SQL语句未用到索引是不会使用行级锁的，会使用表级锁把整张表锁住。 优点： 为数据处理的安全提供保证 缺点： 因加锁，数据库产生额外开销 增加产生死锁的机会 若在只读型事务处理中由于不会产生冲突，没必要使用锁，会增加系统负载，降低并行性 使用版本号实现乐观锁 使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 1.查询出商品信息 select (status,status,version) from t_goods where id=#{id} 2.根据商品信息生成订单 3.修改商品status为2 update t_goods set status=2,version=version+1 where id=#{id} and version=#{version}; 具体案例 考虑电商系统中的下单流程，商品的库存量是固定的，如何保证商品数量不超卖？ 其实需要保证数据一致性：某个人点击秒杀后系统中查出来的库存量和实际扣减库存时库存量的一致性就可以。 假设，MySQL数据库中商品库存表tb_product_stock 结构定义如下： CREATE TABLE `tb_product_stock` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '自增ID', `product_id` bigint(32) NOT NULL COMMENT '商品ID', `number` INT(8) NOT NULL DEFAULT 0 COMMENT '库存数量', `create_time` DATETIME NOT NULL COMMENT '创建时间', `modify_time` DATETIME NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`), UNIQUE KEY `index_pid` (`product_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品库存表'; 对应的POJO类： class ProductStock { private Long productId; //商品id private Integer number; //库存量 public Long getProductId() { return productId; } public void setProductId(Long productId) { this.productId = productId; } public Integer getNumber() { return number; } public void setNumber(Integer number) { this.number = number; } } 不考虑并发的情况下，更新库存代码如下： /** * 更新库存(不考虑并发) * @param productId * @return */ public boolean updateStockRaw(Long productId){ ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId}\", productId); if (product.getNumber() > 0) { int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId}\", productId); if(updateCnt > 0){ //更新库存成功 return true; } } return false; } 多线程并发情况下，会存在超卖的可能。 悲观锁 /** * 更新库存(使用悲观锁) * @param productId * @return */ public boolean updateStock(Long productId){ //先锁定商品库存记录 ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId} FOR UPDATE\", productId); if (product.getNumber() > 0) { int updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId}\", productId); if(updateCnt > 0){ //更新库存成功 return true; } } return false; } 乐观锁 /** * 下单减库存 * @param productId * @return */ public boolean updateStock(Long productId){ int updateCnt = 0; while (updateCnt == 0) { ProductStock product = query(\"SELECT * FROM tb_product_stock WHERE product_id=#{productId}\", productId); if (product.getNumber() > 0) { updateCnt = update(\"UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId} AND number=#{number}\", productId, product.getNumber()); if(updateCnt > 0){ //更新库存成功 return true; } } else { //卖完啦 return false; } } return false; } 使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。 我们的目标是确保库存不能被扣为负数，修改成 UPDATE tb_product_stock SET number=number-1 WHERE product_id=#{productId} AND number > 0; 效率会改善 参考文献 深入理解乐观锁与悲观锁 MySQL 乐观锁与悲观锁 "}}