## 1. cookie与session

***session***

session，是服务器端技术，会为每个客户端创建一个其独享的session对象。可存放文件、内存或数据库，以键值对形式存储

session 的客户端实现形式：

- 使用 Cookie 保存
- URL 重写
- 表单隐藏域

若 cookie 被禁用，可使用后两种把sessionID传给服务器

***session 什么时候被创建？***

1. servlet 中手动调用

   ```java
   HttpSession session = request.getSession();
   HttpSession session = request.getSession(true);
   ```

2. jsp 中没有写 <%@ page session="false"%>（默认 session = "true"）

***session 什么时候被删除？***

1. 程序调用 HttpSession.invalidate()
2. 距离上次收到客户端发送的session id 时间间隔超过了 session 的最大有效时间
3. 服务器进程被停止

------

***cookie***

cookie，是客户端技术，由服务器产生存储在客户端，可以用于**辨别用户身份**、**进行session跟踪**。

***分类*：**

1. 存储在硬盘上的**永久性cookie**
2. 存储在内存上的**临时性cookie**

***有效性*：**

maxAge 决定 cookie 有效期， 单位秒

- 正数：浏览器将 cookie 持久化

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(Integer.MAX_VALUE);
  response.addCookie(cookie);
  ```

- 负数：临时性 cookie （浏览器默认maxAge值 -1）

- 0：删除该 cookie

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(0); // 删除该cookie
  response.addCookie(cookie);
  ```

***cookie 的组成部分***

标准格式：```Set-Cookie: NAME=VALUE; Expires=DATE; Path=PATH; Domain=DOMAIN_NAME; SECURE;```

例子：```Set-Cookie: JSESSIONID=fjdsofjaioufy; Expires=Thu, 05-Jun-2018 05:02:50; Path=/web;```

- expires : 有效时间，过了则自动删除，若不设置，则为临时性cookie
- Path，Domain：一起构成 cookie 的作用范围；Domain可以使多个web服务器共享cookie，path指定与cookie关联一起的网页

---

***cookie 和 session 原理解析：***

- 客户端第一次发请求给服务器，服务器产生一个唯一的 sessionID，并返回给客户端（通过cookie，没有setMaxAge()）
- 客户端将cookie保存在内存中，再发送请求时，会在 request 中携带 cookie
- 服务器根据 cookie 中的 sessionID，可找到对应的session

---

***cookie与 session区别***

1. 存放位置。cookie数据存放在客户端上，session数据存放在服务器上
2. 安全性。cookie由于存放在客户端，所以安全性低，可通过分析存放本地cookie进行cookie欺骗
3. 有效期。cookie可以在浏览器上保存较长时间。session只需关闭浏览器就会失效。
4. 对服务器的压力。cookie保管在客户端，不占用服务器资源。大量并发访问用户，会产生大量session，耗费大量内存。
5. 跨域支持。cookie支持跨域，session不支持，仅在他所在域名内有效。
6. 容量和个数。单个cookie的容量不超过4KB，很多浏览器限制单个站点最多20个cookie。session没有容量个数限制。

**建议**：登录信息等重要信息存放 session 中，其他信息可放在 cookie 中。

---

***session 与 cache 区别***

session 是单用户的会话状态

cache 是服务器端的缓存，所有用户都可访问、共享

---





## 2. 输入网址到浏览器显示页面的过程

1. 浏览器输入网址
2. 域名解析，查找域名的IP
   - 浏览器缓存
   - 系统缓存
   - 路由器缓存
   - ISP DNS缓存
   - ISP DNS服务器递归搜索 
3. 与IP地址对应的服务器建立TCP连接，三次握手
4. 发送HTTP请求
5. 获得服务器响应，显示页面 



**用到协议**：IP、ARP、OSPF、TCP



## 3. 计算机网络体系结构

![计算机网络体系结构](images/计算机网络体系结构.png)

**1. 五层协议**

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。
- **运输层** ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层** ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。
- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的节点提供服务。数据链路层把网络层传来的分组封装成帧。
- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

**2. OSI**

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必担心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

**3. TCP/IP**

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

![](images/TCP-IP体系结构的另一种表示方式.png)

TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。

 ![](images/TCP-IP协议族.png)



## 4. HTTP的请求方法

HTTP1.0有3种：

- GET：从服务器获得一份文档
- POST：向服务器发送需要处理的数据
- HEAD：从服务器获得响应报文的首部

HTTP1.1新增5种：

- OPTIONS：获取服务器支持的HTTP请求方法；检查服务器性能
- PUT：将请求的主体部分存储在服务器上
- DELETE：从服务器上删除一份文件
- TRACE：对可能经过代理服务器传送到服务器上的报文进行追踪
- CONNECT：1.1中预留给能将连接改为管道方式的代理服务器



GET 与 POST的区别：

|              |             GET             |                         POST                         |
| :----------: | :-------------------------: | :--------------------------------------------------: |
|   **用途**   |          获取资源           |                       发送数据                       |
|   **数据**   |    通过URL请求后缀，可见    | 通过POST机制，将字段和对应值封装在请求实体中，不可见 |
|  **数据**量  | 小，受URL长度限制，但效率高 |                    可传输大量数据                    |
|  **安全**性  |       不安全，URL可见       |                         安全                         |
| **支持字符** |          支持ASCLL          |                     支持标准字符                     |



## 5. HTTP的无状态，如何保持状态

HTTP的无状态是指**协议对于事务处理没有记忆能力**。

**优点：节省服务器资源**。服务器不用为每个客户端连接分配内存来记忆大量状态，失去连接时清理内存。

**缺点：传送的数据量可能增大**。若需要之前的信息，客户端需要重传。

保持状态可采用**会话跟踪技术**。把状态保存在服务器中，发送给客户端标志符，客户端下次提交再把标志符发送给服务器，则可以定位存储在服务器上的状态信息。

4种会话跟踪技术：

1. session
2. cookie
3. url 重写
4. 隐藏表单域



## 6. HTTP的短连接和长连接

**HTTP/1.0 中默认使用短连接**。浏览器和服务器每进行一次HTTP操作，就建立一次连接。

需要在 request 中增加“Connection: keep-alive” header 才能建立长连接

HTTP1.0 keepAlive的数据交互流程：

1. 客户端发出request，包含header “Connection: keep-alive”
2. 服务器收到该request后，发出包含header “Connection: keep-alive”的response。同时不会关闭已建立的 TCP 连接
3. 客户端收到response后，不关闭 TCP连接，并用该连接再发生 request。

**HTTP/1.1 中默认使用长连接**。请求和响应都会加入 "Connection: keep-alive"

关闭长连接：

- keepAlive有一个保持时间，可以在服务器软件中设置。 
- 请求或响应中 Connection: closed

**HTTP协议的长连接和短连接，实质是TCP协议的长连接和短连接**



**HTTP长连接的优点：**

1. 减少TCP连接开启和关闭，节约CPU时间和内存
2. 减少TCP连接开启和关闭引起的包数量，降低网络阻塞

**HTTP长连接的缺点：**

服务器维护长连接增加开销



**HTTP短连接的优点：**

节省服务器资源

**HTTP短连接的缺点：**

如果客户端请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。



## 7.HTTP 1.0、1.1、2.0区别

**1.0 与 1.1的区别：**

1. **长连接**

   HTTP 1.0 需要使用 keep-alive 参数来告知服务器端建立长连接。HTTP 1.1 默认支持长连接

2. **状态码 100 Continue**

   HTTP 1.1 支持只发送 header 信息（无 body 信息），当接收到100时，才开始把 body 发送，当收到 401 时，就不发送 body

3. **HOST 域**

   web server上的多个虚拟站点可以共享同一个 ip 和端口。HTTP 1.0 不支持，HTTP 1.1 支持，Request消息头多了一个Host域

4. **分块传输数据**

   HTTP 1.0 通过Content-Length字段指定实体长度，对于动态生成的响应，需要缓存整个响应

   HTTP 1.1 引入分块传输，将消息实体分割为任意大小的组块，单独发送

**1.1 与 2.0的区别：**

1. **多路复用**

   2.0 同一个连接并发处理多个请求

   1.1 则是多建立几个 TCP 连接，来支持并发请求，创建 TCP 连接有开销

2. **数据压缩**

   1.1 不支持 header 数据的压缩

   2.0 使用 HPACK 算法对 header 数据压缩，数据体积小了，在网络上传输速度更快

3. **服务器推送**

   对支持 HTTP 2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，非常适合加载静态资源

   

## 8. HTTP 与 HTTPS

**HTTP存在的安全问题：**

- 通信使用明文，不加密，内容可能被窃听
- 不验证通信对方身份，可能遭到伪装
- 无法验证报文完整性，可能被篡改

HTTPS 在 HTTP 加上 **加密处理 + 认证 + 完整性保护**



**HTTPS 用到的技术：**

1. 对称加密算法：加密传输数据
2. 非对称加密算法：加密生成的密码
3. 数字证书：验证身份
4. 散列算法：验证数据完整性



**HTTP 与 HTTPS 区别**

- HTTPS更安全
- HTTPS需要申请证书
- 端口不同：HTTP 80，HTTPS 443
- 层次不同：HTTP在TCP之上，HTTPS在SSL/TLS之上



## 9. HTTP 状态码
- **1XX ：指示信息**——请求已接收，需要请求者继续执行操作
- **2XX：成功**——操作被成功接收并处理
- **3XX：重定向**——需要进一步操作以完成请求
- **4XX：客户端错误**，请求包含语法错误或无法完成请求
- **5XX：服务器错误**，服务器在处理请求的过程中发生了错误

---

- **200 OK** ：请求被正常处理 
- **202 Accepted** ：已接收请求，但处理尚未完成 
- **204 No Content**：请求被受理但没有资源可以返回
- **206 Partial Content**：客户端进行范围请求，响应报文由 Content-Range 指定实体内容的范围。实现断点续传

---

- **301 Moved Permanently**：永久重定向，请求的网页已永久移到新位置
- **302 Moved Temporatily**：临时重定向，请求网页临时移到新位置
- **304 Not Modified**：未修改。所请求资源未修改，服务器不返回资源，客户端会从缓存中访问资源。

---

- **400 Bad Request**：请求报文语法有误，服务器无法识别
- **401 Unauthorized**：请求需要认证
- **403 Forbidden**：服务器拒绝请求
- **404 Not Found**：服务器无法找到对应资源

---

- **500 Internal Server Error**：服务器内部错误
- **503 Service Unavailable**：服务器正忙



## 10. HTTP的特点

1. 支持CS通信模式
2. 简单方便快捷：协议简单，通信速度快
3. 灵活：运行传输任意类型任意格式的数据对象，由Content-Type标记
4. 无连接
5. 无状态

 

## 11. ARP（地址解析协议）

**解决同一局域网内，主机或路由器的 IP 地址和 MAC 地址的映射问题。**

如果源主机和目的主机在同一个局域网内（目标IP和本机IP与子网掩码相与结果相同，则在同一个子网），可通过ARP找到目的主机的MAC地址；若不在同一局域网内，用ARP找到本网络的一个路由器的MAC地址，剩下工作由路由器完成。

***ARP 协议的具体内容：***

1. 每个主机有ARP高速缓存，存储本局域网内IP地址与MAC地址之间的映射
2. 当源主机发送数据时，首先检查ARP高速缓存中是否有对应IP的MAC地址，若有，则直接发送数据，若没有，向本网段的所有主机发送ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址）
3. 当本网段的所有主机收到ARP请求分组时，检查目的主机IP地址是否是自己的IP地址，若不是，则忽略；若是，则将源主机IP地址和MAC地址写入ARP高速缓存中，将自己的MAC地址写入ARP响应包中。
4. 源主机收到ARP响应分组后，将目的主机IP和MAC地址写入ARP高速缓存。若一直没收到ARP响应分组，则ARP查询失败



## 12. 路由器与交换机的区别

1. 交换机工作在数据链路层；路由器工作在网络层
2. 交换机转发数据帧；路由器转发IP分组
3. 交换机隔离冲突域，不隔离广播域；路由器隔离冲突域，隔离广播域



## 13. TCP如何保证可靠传输

1. 传递数据前，三次握手建立连接
2. 将数据截断为合理的长度
3. 超时重发
4. 对于收到的请求，给出确认响应
5. 效验出包有错，丢弃报文段，不给出响应，TCP发送数据段，超时时会重发数据
6. 对失序数据进行重新排序，再交给应用层
7. 对于重复数据，能够丢弃重复数据
8. TCP提供流量控制，防止较快主机致使较慢主机的缓冲区溢出
9. TCP提供拥塞控制，当网络拥塞时，减少数据发送



## 14. TCP 的三次握手和四次挥手

![TCP三次握手与四次挥手](images/TCP三次握手与四次挥手.jpg)



**为什么需要TIME_WAIT状态**

1、**实现TCP全双工连接的终止**。当客户主动中断连接时，根据TCP协议，客户必须接收服务器的FIN信息并给予ACK应答。因此客户需要维护状态信息，以便能回复ACK。**如果过程中ACK丢失，它必须能够重传，否则将会产生错误**。而处于TIME_WAIT状态没有关闭可以实现。

2、**允许老的重复分节在网络中消失**。如果一个TCP连接关闭，过了一会又在相同的IP和端口建立新的连接。TCP需要防止之前连接没有传完的数据在新的连接出现。而如果连接处于TIME_WAIT状态，就不会给这个相同IP和端口建立新的连接。**之前没有传完的数据将会在TIME_WAIT结束前在网络中消失**，因为TIME_WAIT的持续时间是数据的生存时间MSL的两倍。

---

**什么是2MSL**

MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。 



---

## 15. TCP的流量控制

流量控制：让发送方的发生速率不要太快，让接收方来得及接收

**原理**：**滑动窗口机制**。运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小

![](images/TCP滑动窗口.jpg)

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。**如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口**。

**接收窗口只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。



## 16. TCP的拥塞控制

拥塞控制是为了降低网络的拥塞程度

![](images/拥塞控制的作用.jpg)



4种算法：慢开始、拥塞避免、快重传、快恢复

发送方需要维护一个叫做**拥塞窗口（cwnd）**的状态变量（拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口）

![](images/TCP拥塞控制.png)

1. 慢开始与拥塞避免

   **发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍**，因此之后发送方能够发送的报文段数量为：2、4、8 ...

   注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。**设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1**。

   **如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始**。

2. 快重传与快恢复

   **在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认**。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

   **在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段**。例如收到三个 M2，则 M3 丢失，立即重传 M3。

   在这种情况下，**只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh**，注意到此时**直接进入拥塞避免**。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

   ![](images/快重传.png)

---
## 17. TCP与UDP

   用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

   传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

   **区别：**

   1. 基于连接 vs 无连接

      TCP 面向连接；UDP 无连接

   2. 可靠性

      TCP 提供可靠交付，若有消息丢失，则重发；UDP 不可靠

   3. 有序性

      TCP 会将消息进行排序；UDP 不提供有序性的保证

   4. 速度

      TCP 速度慢；UDP 速度快

   5. 重量级 vs 轻量级

      TCP 重量级，报头最少20字节（序列号、ACK号、数据偏移量、保留、控制位、窗口、紧急指针、可选项、填充项、校验位、源端口、目的端口）

      UDP 轻量级，报头固定8字节（长度、源端口号、目的端口、校验和）

   6. 流量控制或拥塞控制

      TCP 有流量控制和拥塞控制；UDP没有

   7. TCP 面向字节流，UCP 面向报文

   8. TCP 只能单播，UDP 可以广播和组播



**应用场景：**

- TCP：效率要求相对低，准确性要求相对高的场景。如文件传输、邮件传输、远程登录
- UDP：效率要求相对高，准确性要求相对低的场景。如视频聊天、网络电话、广播通信



**TCP安全，但还有很多用UDP？**

- 无需建立连接，减少延迟
- 无需维护连接状态
- 头部开销小
- 应用层能更好控制发送数据和发送时间，网络中的拥塞不会影响主机的发送频率



**UDP为何快？**

- 无需建立连接
- 对于收到的数据，不用给出确认
- 没有超时重传
- 没有流量控制和拥塞控制



## 18. RESTFul

REST - representational state transfer，表现层状态转移

用URL定位资源，用HTTP动词（GET、POST、DELETE、DELETE）描述操作

**优点**
1. 轻量，直接基于http，不在需要任何别的诸如消息协议。get/post/put/delete为CRUD操作
2. 面向资源，一目了然，具有自解释性。
3. 数据描述简单，一般以xml，json做数据交换。

**缺点**

导致设计uri变得复杂了。尤其是复杂的关系，操作，资源集合 。

1. HTTP动词太少，只有CRUD，复杂操作不适用，如部分更新
2. 批量的删除、修改、新增（将多个资源看做单个资源）



## 19. I/O模型

五种I/O模型：

1. **阻塞式I/O**：应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。 

2. **非阻塞式I/O**：应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用（轮询）来获知 I/O 是否完成。 

3. **I/O复用（事件驱动I/O）**：使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。 

4. **信号驱动I/O**：应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。 

5. **异步I/O**：进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

**五大IO模型比较**
前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的：将数据从内核复制到应用进程过程中，应用进程会被阻塞。
![](images/五大IO模型比较.png)

​    



## 20. IO多路复用

I/O多路复用的具体实现：

**1.select**

select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

缺点：

1. 单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。 
2. 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
3. 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。

**2.poll**

poll和select类似，使用链表实现

与select比较：

- 功能
  - select的描述符类型使用数组实现，有限制；poll的描述符类型使用链表实现，没有数量限制
  - poll提供更多的事件类型
  - select会修改描述符，poll不会，重复利用更高
- 速度
  - select和poll都慢
  - 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区 
  - 应用进程都需要使用轮询的方式来找到 I/O 完成的描述符 
- 可移植性
  - 几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。

**3.epoll**

epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。 

工作模式：

LT模式（默认）：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。 

ET模式：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

 **4.应用场景**

1. select 应用场景 

select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于**实时要求更高**的场景，比如核反应堆的控制。

select **可移植性更好**，几乎被所有主流平台所支持。

2. poll 应用场景 

poll **没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select**。

**需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势**。

**需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll**。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。

3. epoll 应用场景

**只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接**。

 

 

 

 



 

 

 

 

 