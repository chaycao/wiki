## 1. cookie与session

***session***

session，是服务器端技术，会为每个客户端创建一个其独享的session对象。可存放文件、内存或数据库，以键值对形式存储

session 的客户端实现形式：

- 使用 Cookie 保存
- URL 重写
- 表单隐藏域

若 cookie 被禁用，可使用后两种把sessionID传给服务器

***session 什么时候被创建？***

1. servlet 中手动调用

   ```java
   HttpSession session = request.getSession();
   HttpSession session = request.getSession(true);
   ```

2. jsp 中没有写 <%@ page session="false"%>（默认 session = "true"）

***session 什么时候被删除？***

1. 程序调用 HttpSession.invalidate()
2. 距离上次收到客户端发送的session id 时间间隔超过了 session 的最大有效时间
3. 服务器进程被停止

------

***cookie***

cookie，是客户端技术，由服务器产生存储在客户端，可以用于**辨别用户身份**、**进行session跟踪**。

***分类*：**

1. 存储在硬盘上的**永久性cookie**
2. 存储在内存上的**临时性cookie**

***有效性*：**

maxAge 决定 cookie 有效期， 单位秒

- 正数：浏览器将 cookie 持久化

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(Integer.MAX_VALUE);
  response.addCookie(cookie);
  ```

- 负数：临时性 cookie （浏览器默认maxAge值 -1）

- 0：删除该 cookie

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(0); // 删除该cookie
  response.addCookie(cookie);
  ```

***cookie 的组成部分***

标准格式：```Set-Cookie: NAME=VALUE; Expires=DATE; Path=PATH; Domain=DOMAIN_NAME; SECURE;```

例子：```Set-Cookie: JSESSIONID=fjdsofjaioufy; Expires=Thu, 05-Jun-2018 05:02:50; Path=/web;```

- expires : 有效时间，过了则自动删除，若不设置，则为临时性cookie
- Path，Domain：一起构成 cookie 的作用范围；Domain可以使多个web服务器共享cookie，path指定与cookie关联一起的网页

---

***cookie 和 session 原理解析：***

- 客户端第一次发请求给服务器，服务器产生一个唯一的 sessionID，并返回给客户端（通过cookie，没有setMaxAge()）
- 客户端将cookie保存在内存中，再发送请求时，会在 request 中携带 cookie
- 服务器根据 cookie 中的 sessionID，可找到对应的session

---

***cookie与 session区别***

1. 存放位置。cookie数据存放在客户端上，session数据存放在服务器上
2. 安全性。cookie由于存放在客户端，所以安全性低，可通过分析存放本地cookie进行cookie欺骗
3. 有效期。cookie可以在浏览器上保存较长时间。session只需关闭浏览器就会失效。
4. 对服务器的压力。cookie保管在客户端，不占用服务器资源。大量并发访问用户，会产生大量session，耗费大量内存。
5. 跨域支持。cookie支持跨域，session不支持，仅在他所在域名内有效。
6. 容量和个数。单个cookie的容量不超过4KB，很多浏览器限制单个站点最多20个cookie。session没有容量个数限制。

**建议**：登录信息等重要信息存放 session 中，其他信息可放在 cookie 中。

---

***session 与 cache 区别***

session 是单用户的会话状态

cache 是服务器端的缓存，所有用户都可访问、共享

---





## 2. 输入网址到浏览器显示页面的过程

1. 浏览器输入网址
2. 域名解析，查找域名的IP
   - 浏览器缓存
   - 系统缓存
   - 路由器缓存
   - ISP DNS缓存
   - ISP DNS服务器递归搜索 
3. 与IP地址对应的服务器建立TCP连接，三次握手
4. 发送HTTP请求
5. 获得服务器响应，显示页面 



**用到协议**：IP、ARP、OSPF、TCP



## 3. 五层网络模型

- 应用层
- 传输层
- 网络层
- 链路层
- 物理层



## 4. HTTP的请求方法

HTTP1.0有3种：

- GET：从服务器获得一份文档
- POST：向服务器发送需要处理的数据
- HEAD：从服务器获得响应报文的首部

HTTP1.1新增5种：

- OPTIONS：获取服务器支持的HTTP请求方法；检查服务器性能
- PUT：将请求的主体部分存储在服务器上
- DELETE：从服务器上删除一份文件
- TRACE：对可能经过代理服务器传送到服务器上的报文进行追踪
- CONNECT：1.1中预留给能将连接改为管道方式的代理服务器



GET 与 POST的区别：

|              |             GET             |                         POST                         |
| :----------: | :-------------------------: | :--------------------------------------------------: |
|   **用途**   |          获取资源           |                       发送数据                       |
|   **数据**   |    通过URL请求后缀，可见    | 通过POST机制，将字段和对应值封装在请求实体中，不可见 |
|  **数据**量  | 小，受URL长度限制，但效率高 |                    可传输大量数据                    |
|  **安全**性  |       不安全，URL可见       |                         安全                         |
| **支持字符** |          支持ASCLL          |                     支持标准字符                     |



## 5. HTTP的无状态，如何保持状态

HTTP的无状态是指**协议对于事务处理没有记忆能力**。

**优点：节省服务器资源**。服务器不用为每个客户端连接分配内存来记忆大量状态，失去连接时清理内存。

**缺点：传送的数据量可能增大**。若需要之前的信息，客户端需要重传。

保持状态可采用**会话跟踪技术**。把状态保存在服务器中，发送给客户端标志符，客户端下次提交再把标志符发送给服务器，则可以定位存储在服务器上的状态信息。

4种会话跟踪技术：

1. session
2. cookie
3. url 重写
4. 隐藏表单域



## 6. HTTP的短连接和长连接

**HTTP/1.0 中默认使用短连接**。浏览器和服务器每进行一次HTTP操作，就建立一次连接。

需要在 request 中增加“Connection: keep-alive” header 才能建立长连接

HTTP1.0 keepAlive的数据交互流程：

1. 客户端发出request，包含header “Connection: keep-alive”
2. 服务器收到该request后，发出包含header “Connection: keep-alive”的response。同时不会关闭已建立的 TCP 连接
3. 客户端收到response后，不关闭 TCP连接，并用该连接再发生 request。

**HTTP/1.1 中默认使用长连接**。请求和响应都会加入 "Connection: keep-alive"

关闭长连接：

- keepAlive有一个保持时间，可以在服务器软件中设置。 
- 请求或响应中 Connection: closed

**HTTP协议的长连接和短连接，实质是TCP协议的长连接和短连接**



**HTTP长连接的优点：**

1. 减少TCP连接开启和关闭，节约CPU时间和内存
2. 减少TCP连接开启和关闭引起的包数量，降低网络阻塞

**HTTP长连接的缺点：**

服务器维护长连接增加开销



**HTTP短连接的优点：**

节省服务器资源

**HTTP短连接的缺点：**

如果客户端请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。



## 7.HTTP 1.0、1.1、2.0区别

1.0 与 1.1的区别：

1. **长连接**

   HTTP 1.0 需要使用 keep-alive 参数来告知服务器端建立长连接。HTTP 1.1 默认支持长连接

2. **节约带宽**

   HTTP 1.1 支持只发送 header 信息（无 body 信息），当接收到100时，才开始把 body 发送，当收到 401 时，就不发送 body

3. **HOST 域**

   web server上的多个虚拟站点可以共享同一个 ip 和端口。HTTP 1.0 不支持，HTTP 1.1 支持

4. **断点续传**

5. **管线化**

   客户端可以同时发出多个 HTTP 请求，不用一个一个等待响应 

1.1 与 2.0的区别：

1. **多路复用**

   2.0 同一个连接并发处理多个请求

   1.1 则是多建立几个 TCP 连接，来支持并发请求，创建 TCP 连接有开销

2. **数据压缩**

   1.1 不支持 header 数据的压缩

   2.0 使用 HPACK 算法对 header 数据压缩，数据体积小了，在网络上传输速度更快

3. **服务器推送**

   对支持 HTTP 2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，非常适合加载静态资源

   

## HTTP 与 HTTPS

**HTTP存在的安全问题：**

- 通信使用明文，不加密，内容可能被窃听
- 不验证通信对方身份，可能遭到伪装
- 无法验证报文完整性，可能被篡改

HTTPS 在 HTTP 加上 **加密处理 + 认证 + 完整性保护**



**HTTPS 用到的技术：**

1. 对称加密算法：加密传输数据
2. 非对称加密算法：加密生成的密码
3. 数字证书：验证身份
4. 散列算法：验证数据完整性



**HTTP 与 HTTPS 区别**

- HTTPS更安全
- HTTPS需要申请证书
- 端口不同：HTTP 80，HTTPS 443
- 层次不同：HTTP在TCP之上，HTTPS在SSL/TLS之上



## 8. HTTP 状态码
- **1XX ：指示信息**——请求已接收，需要请求者继续执行操作
- **2XX：成功**——操作被成功接收并处理
- **3XX：重定向**——需要进一步操作以完成请求
- **4XX：客户端错误**，请求包含语法错误或无法完成请求
- **5XX：服务器错误**，服务器在处理请求的过程中发生了错误

---

- **200 OK** ：请求被正常处理 
- **202 Accepted** ：已接收请求，但处理尚未完成 
- **204 No Content**：请求被受理但没有资源可以返回
- **206 Partial Content**：客户端进行范围请求，响应报文由 Content-Range 指定实体内容的范围。实现断点续传

---

- **301 Moved Permanently**：永久重定向，请求的网页已永久移到新位置
- **302 Moved Temporatily**：临时重定向，请求网页临时移到新位置
- **304 Not Modified**：未修改。所请求资源未修改，服务器不返回资源，客户端会从缓存中访问资源。

---

- **400 Bad Request**：请求报文语法有误，服务器无法识别
- **401 Unauthorized**：请求需要认证
- **403 Forbidden**：服务器拒绝请求
- **404 Not Found**：服务器无法找到对应资源

---

- **500 Internal Server Error**：服务器内部错误
- **503 Service Unavailable**：服务器正忙



## 9. HTTP的特点

1. 支持CS通信模式
2. 简单方便快捷：协议简单，通信速度快
3. 灵活：运行传输任意类型任意格式的数据对象，由Content-Type标记
4. 无连接
5. 无状态

 

## 10. ARP（地址解析协议）

**解决同一局域网内，主机或路由器的 IP 地址和 MAC 地址的映射问题。**

如果源主机和目的主机在同一个局域网内（目标IP和本机IP与子网掩码相与结果相同，则在同一个子网），可通过ARP找到目的主机的MAC地址；若不在同一局域网内，用ARP找到本网络的一个路由器的MAC地址，剩下工作由路由器完成。

***ARP 协议的具体内容：***

1. 每个主机有ARP高速缓存，存储本局域网内IP地址与MAC地址之间的映射
2. 当源主机发送数据时，首先检查ARP高速缓存中是否有对应IP的MAC地址，若有，则直接发送数据，若没有，向本网段的所有主机发送ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址）
3. 当本网段的所有主机收到ARP请求分组时，检查目的主机IP地址是否是自己的IP地址，若不是，则忽略；若是，则将源主机IP地址和MAC地址写入ARP高速缓存中，将自己的MAC地址写入ARP响应包中。
4. 源主机收到ARP响应分组后，将目的主机IP和MAC地址写入ARP高速缓存。若一直没收到ARP响应分组，则ARP查询失败



## 11. 路由器与交换机的区别

1. 交换机工作在数据链路层；路由器工作在网络层
2. 交换机转发数据帧；路由器转发IP分组
3. 交换机隔离冲突域，不隔离广播域；路由器隔离冲突域，隔离广播域



## 12. TCP如何保证可靠传输

1. 传递数据前，三次握手建立连接
2. 将数据截断为合理的长度
3. 超时重发
4. 对于受到的请求，给出确认响应
5. 效验出包有错，丢弃报文段，不给出响应，TCP发送数据段，超时时会重发数据
6. 对失序数据进行重新排序，再交给应用层
7. 对于重复数据，能够丢弃重复数据
8. TCP提供流量控制，防止较快主机致使较慢主机的缓冲区溢出
9. TCP提供拥塞控制，当网络拥塞时，减少数据发送



## 13. TCP 的三次握手和四次挥手

![TCP三次握手与四次挥手](images/TCP三次握手与四次挥手.jpg)