## 1. cookie与session

***session***

session，是服务器端技术，会为每个客户端创建一个其独享的session对象。可存放文件、内存或数据库，以键值对形式存储

session 的客户端实现形式：

- 使用 Cookie 保存
- URL 重写
- 表单隐藏域

若 cookie 被禁用，可使用后两种把sessionID传给服务器

***session 什么时候被创建？***

1. servlet 中手动调用

   ```java
   HttpSession session = request.getSession();
   HttpSession session = request.getSession(true);
   ```

2. jsp 中没有写 <%@ page session="false"%>（默认 session = "true"）

***session 什么时候被删除？***

1. 程序调用 HttpSession.invalidate()
2. 距离上次收到客户端发送的session id 时间间隔超过了 session 的最大有效时间
3. 服务器进程被停止

------

***cookie***

cookie，是客户端技术，由服务器产生存储在客户端，可以用于**辨别用户身份**、**进行session跟踪**。

***分类*：**

1. 存储在硬盘上的**永久性cookie**
2. 存储在内存上的**临时性cookie**

***有效性*：**

maxAge 决定 cookie 有效期， 单位秒

- 正数：浏览器将 cookie 持久化

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(Integer.MAX_VALUE);
  response.addCookie(cookie);
  ```

- 负数：临时性 cookie （浏览器默认maxAge值 -1）

- 0：删除该 cookie

  ```java
  Cookie cookie = new Cookie("username", "chaycao");
  cookie.setMaxAge(0); // 删除该cookie
  response.addCookie(cookie);
  ```

***cookie 的组成部分***

标准格式：```Set-Cookie: NAME=VALUE; Expires=DATE; Path=PATH; Domain=DOMAIN_NAME; SECURE;```

例子：```Set-Cookie: JSESSIONID=fjdsofjaioufy; Expires=Thu, 05-Jun-2018 05:02:50; Path=/web;```

- expires : 有效时间，过了则自动删除，若不设置，则为临时性cookie
- Path，Domain：一起构成 cookie 的作用范围；Domain可以使多个web服务器共享cookie，path指定与cookie关联一起的网页

---

***cookie 和 session 原理解析：***

- 客户端第一次发请求给服务器，服务器产生一个唯一的 sessionID，并返回给客户端（通过cookie，没有setMaxAge()）
- 客户端将cookie保存在内存中，再发送请求时，会在 request 中携带 cookie
- 服务器根据 cookie 中的 sessionID，可找到对应的session

---

***cookie与 session区别***

1. 存放位置。cookie数据存放在客户端上，session数据存放在服务器上
2. 安全性。cookie由于存放在客户端，所以安全性低，可通过分析存放本地cookie进行cookie欺骗
3. 有效期。cookie可以在浏览器上保存较长时间。session只需关闭浏览器就会失效。
4. 对服务器的压力。cookie保管在客户端，不占用服务器资源。大量并发访问用户，会产生大量session，耗费大量内存。
5. 跨域支持。cookie支持跨域，session不支持，仅在他所在域名内有效。
6. 容量和个数。单个cookie的容量不超过4KB，很多浏览器限制单个站点最多20个cookie。session没有容量个数限制。

**建议**：登录信息等重要信息存放 session 中，其他信息可放在 cookie 中。

---

***session 与 cache 区别***

session 是单用户的会话状态

cache 是服务器端的缓存，所有用户都可访问、共享

---





## 2. 输入网址到浏览器显示页面的过程

1. 浏览器输入网址
2. 域名解析，查找域名的IP
   - 浏览器缓存
   - 系统缓存
   - 路由器缓存
   - ISP DNS缓存
   - ISP DNS服务器递归搜索 
3. 与IP地址对应的服务器建立TCP连接，三次握手
4. 发送HTTP请求
5. 获得服务器响应，显示页面 



**用到协议**：IP、ARP、OSPF、TCP



## 3. 五层网络模型

- 应用层
- 传输层
- 网络层
- 链路层
- 物理层



## 4. HTTP的请求方法

HTTP1.0有3种：

- GET：从服务器获得一份文档
- POST：向服务器发送需要处理的数据
- HEAD：从服务器获得响应报文的首部

HTTP1.1新增5种：

- OPTIONS：获取服务器支持的HTTP请求方法；检查服务器性能
- PUT：将请求的主体部分存储在服务器上
- DELETE：从服务器上删除一份文件
- TRACE：对可能经过代理服务器传送到服务器上的报文进行追踪
- CONNECT：1.1中预留给能将连接改为管道方式的代理服务器



GET 与 POST的区别：

|              |             GET             |                         POST                         |
| :----------: | :-------------------------: | :--------------------------------------------------: |
|   **用途**   |          获取资源           |                       发送数据                       |
|   **数据**   |    通过URL请求后缀，可见    | 通过POST机制，将字段和对应值封装在请求实体中，不可见 |
|  **数据**量  | 小，受URL长度限制，但效率高 |                    可传输大量数据                    |
|  **安全**性  |       不安全，URL可见       |                         安全                         |
| **支持字符** |          支持ASCLL          |                     支持标准字符                     |



## 5. HTTP的无状态，如何保持状态

HTTP的无状态是指**协议对于事务处理没有记忆能力**。

**优点：节省服务器资源**。服务器不用为每个客户端连接分配内存来记忆大量状态，失去连接时清理内存。

**缺点：传送的数据量可能增大**。若需要之前的信息，客户端需要重传。

保持状态可采用**会话跟踪技术**。把状态保存在服务器中，发送给客户端标志符，客户端下次提交再把标志符发送给服务器，则可以定位存储在服务器上的状态信息。

4种会话跟踪技术：

1. session
2. cookie
3. url 重写
4. 隐藏表单域



## 6. HTTP的短连接和长连接

**HTTP/1.0 中默认使用短连接**。浏览器和服务器每进行一次HTTP操作，就建立一次连接。

需要在 request 中增加“Connection: keep-alive” header 才能建立长连接

HTTP1.0 keepAlive的数据交互流程：

1. 客户端发出request，包含header “Connection: keep-alive”
2. 服务器收到该request后，发出包含header “Connection: keep-alive”的response。同时不会关闭已建立的 TCP 连接
3. 客户端收到response后，不关闭 TCP连接，并用该连接再发生 request。

**HTTP/1.1 中默认使用长连接**。请求和响应都会加入 "Connection: keep-alive"

关闭长连接：

- keepAlive有一个保持时间，可以在服务器软件中设置。 
- 请求或响应中 Connection: closed

**HTTP协议的长连接和短连接，实质是TCP协议的长连接和短连接**



**HTTP长连接的优点：**

1. 减少TCP连接开启和关闭，节约CPU时间和内存
2. 减少TCP连接开启和关闭引起的包数量，降低网络阻塞

**HTTP长连接的缺点：**

服务器维护长连接增加开销



**HTTP短连接的优点：**

节省服务器资源

**HTTP短连接的缺点：**

如果客户端请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。



## 7.HTTP 1.0、1.1、2.0区别

**1.0 与 1.1的区别：**

1. **长连接**

   HTTP 1.0 需要使用 keep-alive 参数来告知服务器端建立长连接。HTTP 1.1 默认支持长连接

2. **状态码 100 Continue**

   HTTP 1.1 支持只发送 header 信息（无 body 信息），当接收到100时，才开始把 body 发送，当收到 401 时，就不发送 body

3. **HOST 域**

   web server上的多个虚拟站点可以共享同一个 ip 和端口。HTTP 1.0 不支持，HTTP 1.1 支持，Request消息头多了一个Host域

4. **分块传输数据**

   HTTP 1.0 通过Content-Length字段指定实体长度，对于动态生成的响应，需要缓存整个响应

   HTTP 1.1 引入分块传输，将消息实体分割为任意大小的组块，单独发送

**1.1 与 2.0的区别：**

1. **多路复用**

   2.0 同一个连接并发处理多个请求

   1.1 则是多建立几个 TCP 连接，来支持并发请求，创建 TCP 连接有开销

2. **数据压缩**

   1.1 不支持 header 数据的压缩

   2.0 使用 HPACK 算法对 header 数据压缩，数据体积小了，在网络上传输速度更快

3. **服务器推送**

   对支持 HTTP 2.0 的 web server 请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，非常适合加载静态资源

   

## 8. HTTP 与 HTTPS

**HTTP存在的安全问题：**

- 通信使用明文，不加密，内容可能被窃听
- 不验证通信对方身份，可能遭到伪装
- 无法验证报文完整性，可能被篡改

HTTPS 在 HTTP 加上 **加密处理 + 认证 + 完整性保护**



**HTTPS 用到的技术：**

1. 对称加密算法：加密传输数据
2. 非对称加密算法：加密生成的密码
3. 数字证书：验证身份
4. 散列算法：验证数据完整性



**HTTP 与 HTTPS 区别**

- HTTPS更安全
- HTTPS需要申请证书
- 端口不同：HTTP 80，HTTPS 443
- 层次不同：HTTP在TCP之上，HTTPS在SSL/TLS之上



## 9. HTTP 状态码
- **1XX ：指示信息**——请求已接收，需要请求者继续执行操作
- **2XX：成功**——操作被成功接收并处理
- **3XX：重定向**——需要进一步操作以完成请求
- **4XX：客户端错误**，请求包含语法错误或无法完成请求
- **5XX：服务器错误**，服务器在处理请求的过程中发生了错误

---

- **200 OK** ：请求被正常处理 
- **202 Accepted** ：已接收请求，但处理尚未完成 
- **204 No Content**：请求被受理但没有资源可以返回
- **206 Partial Content**：客户端进行范围请求，响应报文由 Content-Range 指定实体内容的范围。实现断点续传

---

- **301 Moved Permanently**：永久重定向，请求的网页已永久移到新位置
- **302 Moved Temporatily**：临时重定向，请求网页临时移到新位置
- **304 Not Modified**：未修改。所请求资源未修改，服务器不返回资源，客户端会从缓存中访问资源。

---

- **400 Bad Request**：请求报文语法有误，服务器无法识别
- **401 Unauthorized**：请求需要认证
- **403 Forbidden**：服务器拒绝请求
- **404 Not Found**：服务器无法找到对应资源

---

- **500 Internal Server Error**：服务器内部错误
- **503 Service Unavailable**：服务器正忙



## 10. HTTP的特点

1. 支持CS通信模式
2. 简单方便快捷：协议简单，通信速度快
3. 灵活：运行传输任意类型任意格式的数据对象，由Content-Type标记
4. 无连接
5. 无状态

 

## 11. ARP（地址解析协议）

**解决同一局域网内，主机或路由器的 IP 地址和 MAC 地址的映射问题。**

如果源主机和目的主机在同一个局域网内（目标IP和本机IP与子网掩码相与结果相同，则在同一个子网），可通过ARP找到目的主机的MAC地址；若不在同一局域网内，用ARP找到本网络的一个路由器的MAC地址，剩下工作由路由器完成。

***ARP 协议的具体内容：***

1. 每个主机有ARP高速缓存，存储本局域网内IP地址与MAC地址之间的映射
2. 当源主机发送数据时，首先检查ARP高速缓存中是否有对应IP的MAC地址，若有，则直接发送数据，若没有，向本网段的所有主机发送ARP请求分组（源主机IP地址，源主机MAC地址，目的主机IP地址）
3. 当本网段的所有主机收到ARP请求分组时，检查目的主机IP地址是否是自己的IP地址，若不是，则忽略；若是，则将源主机IP地址和MAC地址写入ARP高速缓存中，将自己的MAC地址写入ARP响应包中。
4. 源主机收到ARP响应分组后，将目的主机IP和MAC地址写入ARP高速缓存。若一直没收到ARP响应分组，则ARP查询失败



## 12. 路由器与交换机的区别

1. 交换机工作在数据链路层；路由器工作在网络层
2. 交换机转发数据帧；路由器转发IP分组
3. 交换机隔离冲突域，不隔离广播域；路由器隔离冲突域，隔离广播域



## 13. TCP如何保证可靠传输

1. 传递数据前，三次握手建立连接
2. 将数据截断为合理的长度
3. 超时重发
4. 对于收到的请求，给出确认响应
5. 效验出包有错，丢弃报文段，不给出响应，TCP发送数据段，超时时会重发数据
6. 对失序数据进行重新排序，再交给应用层
7. 对于重复数据，能够丢弃重复数据
8. TCP提供流量控制，防止较快主机致使较慢主机的缓冲区溢出
9. TCP提供拥塞控制，当网络拥塞时，减少数据发送



## 14. TCP 的三次握手和四次挥手

![TCP三次握手与四次挥手](images/TCP三次握手与四次挥手.jpg)

---

## 15. TCP的流量控制

流量控制：让发送方的发生速率不要太快，让接收方来得及接收

**原理**：**滑动窗口机制**。运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小

![](images/TCP滑动窗口.jpg)

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。**如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口**。

**接收窗口只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。



## 16. TCP的拥塞控制

拥塞控制是为了降低网络的拥塞程度

![](images/拥塞控制的作用.jpg)



4种算法：慢开始、拥塞避免、快重传、快恢复

发送方需要维护一个叫做**拥塞窗口（cwnd）**的状态变量（拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口）

![](images/TCP拥塞控制.png)

1. 慢开始与拥塞避免

   **发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍**，因此之后发送方能够发送的报文段数量为：2、4、8 ...

   注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。**设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1**。

   **如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始**。

2. 快重传与快恢复

   **在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认**。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

   **在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段**。例如收到三个 M2，则 M3 丢失，立即重传 M3。

   在这种情况下，**只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh**，注意到此时**直接进入拥塞避免**。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

   ![](images/快重传.png)

---
## 17. TCP与UDP

   用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

   传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

   **区别：**

   1. 基于连接 vs 无连接

      TCP 面向连接；UDP 无连接

   2. 可靠性

      TCP 提供可靠交付，若有消息丢失，则重发；UDP 不可靠

   3. 有序性

      TCP 会将消息进行排序；UDP 不提供有序性的保证

   4. 速度

      TCP 速度慢；UDP 速度快

   5. 重量级 vs 轻量级

      TCP 重量级，报头最少20字节（序列号、ACK号、数据偏移量、保留、控制位、窗口、紧急指针、可选项、填充项、校验位、源端口、目的端口）

      UDP 轻量级，报头固定8字节（长度、源端口号、目的端口、校验和）

   6. 流量控制或拥塞控制

      TCP 有流量控制和拥塞控制；UDP没有

   7. TCP 面向字节流，UCP 面向报文

   8. TCP 只能单播，UDP 可以广播和组播



**应用场景：**

- TCP：效率要求相对低，准确性要求相对高的场景。如文件传输、邮件传输、远程登录
- UDP：效率要求相对高，准确性要求相对低的场景。如视频聊天、网络电话、广播通信



**TCP安全，但还有很多用UDP？**

- 无需建立连接，减少延迟
- 无需维护连接状态
- 头部开销小
- 应用层能更好控制发送数据和发送时间，网络中的拥塞不会影响主机的发送频率



**UDP为何快？**

- 无需建立连接
- 对于收到的数据，不用给出确认
- 没有超时重传
- 没有流量控制和拥塞控制



## 18. RESTFul

REST - representational state transfer，表现层状态转移

用URL定位资源，用HTTP动词（GET、POST、DELETE、DELETE）描述操作

**优点**
1. 轻量，直接基于http，不在需要任何别的诸如消息协议。get/post/put/delete为CRUD操作
2. 面向资源，一目了然，具有自解释性。
3. 数据描述简单，一般以xml，json做数据交换。

**缺点**

导致设计uri变得复杂了。尤其是复杂的关系，操作，资源集合 。

1. HTTP动词太少，只有CRUD，复杂操作不适用，如部分更新
2. 批量的删除、修改、新增（将多个资源看做单个资源）