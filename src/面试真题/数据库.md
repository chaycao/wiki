## 1. 索引的失效情况

（1）条件中有or，有列不带索引

（2）对于多列索引，不是使用的第一部分

（3）like查询以%开头

（4）列是字符串，数据没用引号括起来

（5）mysql估计全表扫描比索引快 

[参考](https://blog.csdn.net/guoxingege/article/details/51034387)



## 2. 索引的实现原理

索引是数据库中一种排序数据结构，通常使用B树及其变种B+树，能有效的利用系统对磁盘的块读取特性，一个节点的大小为一页（4K），每个节点只需要一次IO读取。在读取相同磁盘块的同时，提高索引命中效率，达到减少磁盘IO的读取次数 



## 3. 索引为什么不使用红黑树

虽然红黑树能达到高效的查询效率，但其基本是在内存中才会使用的数据结构。

在数据库中，数据存放在磁盘上，由于操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇，这使得磁盘读写有一个最少内容的限制，也就是当需要簇上的一字节内容，我们需要把整个簇的内容都读完。

试想红黑树中，一个父节点只有两个子节点，不能填满一个簇上的所有内容。一次IO操作获得的簇上只有两个子节点的信息。

再看看B+树，由于B+树节点的分支比二叉树更多，所以相同数量的内容，B+树的深度更浅，也表示磁盘IO操作次数更少。数据库设计的时候B+树具有多少分支是按照磁盘一个簇能存放多少节点设计的。



## 4. 为什么B+树比B树更适合数据库索引？

1. **B+树的磁盘读写次数更少**。B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。 
2. **B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 
3. **B+树只需要去遍历叶子节点就可以实现整棵树的遍历** ，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。 



## 5. 聚簇索引与非聚簇索引

聚簇索引的逻辑顺序是数据在磁盘上的物理存储顺序

非聚簇索引的逻辑顺序与数据在磁盘上的物理存储顺序无关。



## 6. 如何分库分表

**原理：**

通过hash算法或工具将一张数据表垂直或水平地进行物理切分。

**使用场景：** 

1. 单表记录过大，达百万级或千万级；
2. 解决表锁的问题，提高效率

**分表方式：**

1. 水平分表：降低查询时读的数据和索引的页数，降低了索引的层数，提高查询效率
   - 使用场景：
     - 表中数据本身具有独立性，如不同地区数据或不同时期数据，某些数据常用，某些数据不常用
     - 把数据放多个介质上
   - 缺点：
     - 给应用增加复杂度，查询时需要多个表名，查询所有数据需要UNION操作
     - 查询时需要增加读一个索引层的磁盘次数
2. 垂直分表：把主键和一部分列放一个表，接着把主键和另一部分列放一个表。
   - 适用场景：
     - 某些列常用，一些列不常用
   - 缺点：
     - 管理冗余列，查询所有数据需要join操作



## 7. 分区

对用户而言，分区表是一个独立的逻辑表，但是底层MySQL将其分成了多个物理子表，这对用户来说是透明的，每一个分区表都会使用一个独立的表文件。 

创建表时使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有需要的数据的分区，这样只需要查询数据所在分区即可。 

分区的主要目的是将数据按照一个较粗的粒度分在不同的表中，这样可以将相关的数据存放在一起，而且如果想一次性的删除整个分区的数据也很方便。

  **适用场景**  

1、表非常大，无法全部存在内存，或者只在表的最后有热点数据，其他都是历史数据。 

2、分区表的数据更易维护，可以对独立的分区进行独立的操作。 

3、分区表的数据可以分布在不同的机器上，从而高效适用资源。  

4、可以使用分区表来避免某些特殊的瓶颈  

5、可以备份和恢复独立的分区 



## 8. 事务隔离级别

由弱到强：

- 未提交读（Read Uncommited）：（脏读、不可重复读、幻读）
- 已提交读（Read Committed）：只能读到已提交的数据，Oracle等数据库默认级别（不可重复读、幻读）
- 可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别（幻读）
- 串行读（Serializable）：完全串行化的读，每次读都要获取表级共享锁，读写相互阻塞

事务并行产生问题：

- 脏读：当A事务在对数据进行修改，并且还没提交，事务B也能访问、使用该数据 
- 不可重复读：在A事务内，多次读同一数据，由于B事务在两次读数据之间，对数据进行修改，导致两次读到的数据不同（重点在于修改，两次读取的值不同）
- 幻读：A事务对表中所有数据进行修改，事务B修改数据，如插入了一条记录，A事务执行完后，表中存在未修改的数据（重点在于新增或删除，两次读取的记录数不同）



## 9. MVCC

MVCC（Multi-Version Concurrent Control），多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的快照，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这里的版本可以是时间戳或全局递增的事务ID。在同一个时间点，不同的事务看到的数据版本不同。

**mysql 的 InnoDB 引擎如何实现MVCC？** 

为每一行添加两个隐藏字段，记录该行数据何时被创建、何时被删除，具体存储的是事务的版本号，随着新事务开启其版本号会增加。在可重复读Repeated Read级别下：

- SELECT：读取创建版本号 <= 当前事务版本号；删除版本号为空或 > 当前事务版本号
- INSERT：保存当前事务版本号为行的创建版本号
- DELETE：保存当前事务版本号为行的删除版本号
- UPDATE：插入一条新纪录，保存当前事务版本号为行的创建版本号，同时保存当前事务版本号为原来行的删除版本号

**Mysql的RR级别能避免幻读，如何解决？**

Gap锁，在锁住行的两边区间加gap锁，防止别的事务新增。

行锁和Gap锁结合形成的Next-Key锁共同解决了RR级别在写数据时的幻读问题。



## 10. 范式

1NF ：字段不可再分，原子性

2NF ：满足1NF。一个表只能说明一个事物，非主键属性必须**完全依赖**于主键属性。

3NF ：满足2NF。每列都与主键有关系，**不存在传递依赖**。任何非主属性不依赖于其他非主属性。



不符合1NF：

表：字段1，字段2（字段2.1，字段2.2），字段3

不符合2NF：

表：学号，姓名，年龄，课程名称，成绩，学分

不符合3NF：

学号，姓名，年龄，所在学院，学院地点，学院联系电话

传递依赖：学号->所在学院->（学院地点，学院联系电话）



## 11. truncate、delete、drop

相同点：

1. truncate和不带where子句的delete、以及drop都会删除表内的数据。
2. drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。

 

不同点：

1. **truncate 和 delete 删除数据，不删除表的结构(定义)**

   **drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)**；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。

2. **delete 语句是数据库操作语言(dml)**，事务提交之后才生效，可回滚，触发 trigger。
   **truncate、drop 是数据库定义语言(ddl)**，操作立即生效，不能回滚，不触发 trigger

3. delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动
   drop 语句将表所占用的空间全部释放。
   truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。

4. **速度**，一般来说: drop> truncate > delete

5. 安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及
  使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.
  想删除表,当然用 drop
  想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。
  如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。

6. TRUNCATE   TABLE   删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用   DELETE。如果要删除表定义及其数据，请使用   DROP   TABLE   语句。  

7. 对于由   FOREIGN   KEY   约束引用的表，不能使用   TRUNCATE   TABLE，而应使用不带   WHERE   子句的   DELETE   语句。由于   TRUNCATE   TABLE   不记录在日志中，所以它不能激活触发器。    

8. TRUNCATE   TABLE   不能用于参与了索引视图的表。  



## 12. 事务的四大特性 

ACID：原子性、一致性、隔离性、持久性



## 13. 存储引擎 MyISAM、InnoDB、Memory

**MyISAM与InnoDB的区别：**

1. **事务**
   - MyISAM不支持事务
   - InnoDB支持事务
2. **外键** 
   - MyISAM不支持外键
   - InnoDB支持外键
3. **锁**
   - MyISAM只支持表级锁
   - InnoDB支持行级锁、表级锁，默认行级锁
4. **全文索引** 
   - MyISAM支持全文索引
   - InnoDB不支持全文索引（5.6以后开始支持）
5. **表主键** 
   - MyISAM 允许表没有主键
   - InnoDB 若未设定主键，会自动生成一个6字节的主键（用户不可见）
6. **表的具体行数** 
   - MyISAM 保存表的行数
   - InnoDB 不保存表的行数，需要扫描整个表计算行数

---

**MyISAM和InnoDB的应用场景：**

- MyISAM：适用查询性能要求较高、非事务表。查询性能优于InnoDB的原因是，MyISAM的索引和数据是分开的，可以更好的利用内存
- InnoDB：用于事务处理程序。执行大量Insert和Update操作，

---

**Memory存储引擎**

- 使用存储在内存中的数据来创建表，数据全部放在内存中。
- 默认使用Hash索引，速度比B型树索引快
- 若内存出现异常会影响数据，如果重启或关机，数据全部消失。



## 14. 优化查询SQL

- 检查索引

  在SQL语句的 where 和 join 部分中用到的所有字段，都应该加上索引

- 限制工作数据集的大小

  检查是否可以应用 where 进行

- 删除不需要的字段、表

- 删除 where 和 join 子句的计算字段



## 15. 查询语句不同元素的执行先后顺序（where、join、limit、group by、having）

**书写顺序：** 

select -- from -- where -- group by -- having -- order by

**执行顺序：**

- from：从哪个表检索数据
- where ：过滤表中的条件
- group by：对过滤的数据分组
- having：对分组后的数据进行过滤
- select：查看结果集中哪个列，或列的计算结果
- order by：按照什么顺序来查看返回数据

**from、where 条件的解析顺序**

from 的表关联是 自右向左 （数据量小的表放最右边，用小表匹配大表）

where 的条件 是 自左向右 （排除越大数据的条件放左边）



## 16. 临时表



## 17. 索引类型

**从数据结构角度**

1、**B+树索引**(O(log(n)))：关于B+树索引，可以参考 [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

2、**hash索引**：
a 仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询
b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
c 只有Memory存储引擎显示支持hash索引

3、**FULLTEXT索引**（现在MyISAM和InnoDB引擎都支持了）

4、**R-Tree索引**（用于对GIS数据类型创建SPATIAL索引）

---

**从物理存储角度**

1、聚集索引（clustered index）

2、非聚集索引（non-clustered index）

---

**从逻辑角度**

1、**主键索引**：主键索引是一种特殊的唯一索引，不允许有空值

2、**普通索引或者单列索引**

3、**多列索引（复合索引）**：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合

4、**唯一索引或者非唯一索引**

5、**空间索引**：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。
MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建

```
CREATE TABLE table_name[col_name data type]
[unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
```

1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；

2、index和key为同义词，两者作用相同，用来指定创建索引

3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；

4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；

5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；

6、asc或desc指定升序或降序的索引值存储



## 18. 乐观锁、悲观锁

**悲观锁**

先获取锁、再进行业务操作

一锁二查三更新

需要数据库本身提供支持。select ... for update 实现悲观锁。获取的行锁在当前事务结束时自动释放，必须在事务中使用。

MySQL中 select ... for update 执行中所有扫描过的行都会上锁，因此用悲观锁务必要确定使用索引，不是全表扫描

**乐观锁**

乐观并发控制。不加锁，进行业务操作，在提交数据更新前，检查在该事务读取数据后，有没有其他事务修改该数据。若有，则当前提交的事务会回滚。

不需要数据库提供支持。在需要锁的数据上增加一个版本号，或时间戳

**应用场景**

乐观锁：需要非常高的响应速度，成功就执行，不成功则失败

悲观锁：冲突频率非常高，重试代价大



## 19. 非关系型数据库和关系型数据库区别

**非关系型数据库：**

- **性能高**，基于键值对，不需要经过SQL层解析
- **可扩展性**，基于键值对，数据之间没有耦合性

**关系型数据库：**

- **复杂查询**，用SQL语句方便在一个表或多个表之间做非常复杂的查询
- **事务支持**



## 20. 主从复制

**三种方式：**

- **同步复制**：master的变化，必须等待 slave-1，slave-2，...，slave-n完成才能返回。不可取。比如，在WEN前端页面上，用户增加条记录，需要等待很长时间。
- **异步复制**：master只需完成自己的数据库操作，不用关心slaves是否收到二进制日志。MySQL的默认设置
- **半同步复制**：master只保证slaves中的一个操作成功，就返回，其他slaves不管



**问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？** 

假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此**slave不应该进行写操作** 



**问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？**

实现数据备份，读写分离



**问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?** 





