## 1. Java什么时候会发生内存泄露 

内存泄露是指不再使用的对象，被某个对象持有该引用导致GC不能回收。有以下几种情况：

1. 使用静态成员变量的容器对象，持有过多数据
2. 连接资源未释放，如数据库连接、网络连接、IO连接等，其原因是长生命周期对象拥有短生命周期对象引用



## 2. GC算法和机制

从三个方面讲述

（1）什么时候触发GC

当新生代中的eden区满了，会触发minor gc；

当要升到老年代的对象大于老年代剩余空间会触发full gc，或者小于时被HandlePromotionFailure参数强制full gc。

（2）哪些对象需要被回收

从GC Roots搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。

（3）如何回收

对于新生代使用复制算法，将Eden和from surivor中还活着的对象一次性复制到to surivor中，再清理掉Eden和From Survior空间。

对于老年代使用标记清除或标记整理算法。标记清除首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象，但是会产生大量不连续的内存碎片；标记整理的标记与标记清除相同，但不是直接回收对象，而是将所有存活的对象向一端移动，然后直接清理掉边界以外的内存 。



## 3. JVM内存模型

JVM内存模型被分为以下几个区域：

（1）程序计数器：记录当前线程执行字节码指令的地址

（2）虚拟机栈：当方法执行时，会创建一个栈帧，存放局部变量表、操作数栈、方法出口等信息。

（3）本地方法栈：Native方法执行时使用，与虚拟机栈类似

（4）虚拟机堆：所有创建的对象都在堆中分配内存并初始化

（5）方法区：存放虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等信息

其中程序计数器、虚拟机栈、本地方法栈为线程私有